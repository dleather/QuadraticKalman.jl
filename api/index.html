<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · QuadraticKalman.jl</title><meta name="title" content="API Reference · QuadraticKalman.jl"/><meta property="og:title" content="API Reference · QuadraticKalman.jl"/><meta property="twitter:title" content="API Reference · QuadraticKalman.jl"/><meta name="description" content="Documentation for QuadraticKalman.jl."/><meta property="og:description" content="Documentation for QuadraticKalman.jl."/><meta property="twitter:description" content="Documentation for QuadraticKalman.jl."/><meta property="og:url" content="https://dleather.github.io/QuadraticKalman.jl/stable/api/"/><meta property="twitter:url" content="https://dleather.github.io/QuadraticKalman.jl/stable/api/"/><link rel="canonical" href="https://dleather.github.io/QuadraticKalman.jl/stable/api/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-XXXXXXXXX-X"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-XXXXXXXXX-X', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">QuadraticKalman.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Plotting-API"><span>Plotting API</span></a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/dleather/QuadraticKalman.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/dleather/QuadraticKalman.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><h3 id="Main-Types"><a class="docs-heading-anchor" href="#Main-Types">Main Types</a><a id="Main-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Main-Types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.QKData" href="#QuadraticKalman.QKData"><code>QuadraticKalman.QKData</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QKData{T&lt;:Real,N}</code></pre><p>A data structure for holding an <code>M x T_bar</code> array of real values (<code>Y</code>) plus two integer fields (<code>M</code>, <code>T_bar</code>) derived from its dimensions. <code>M</code> is  the dimension of the measurement vector, &#39;Y<em>t&#39;, and `T</em>bar` is the  number of time periods minus 1 (due to the autoregressive structure of the model).</p><p><strong>Fields</strong></p><ul><li><code>Y::AbstractArray{T, N}</code> : The underlying data array (N-dimensional, element type <code>&lt;: Real</code>).</li><li><code>M::Int</code> : The first dimension of <code>Y</code> if <code>Y</code> is at least 2D. If <code>N == 1</code>, we define <code>M = 1</code>.</li><li><code>T_bar::Int</code> : One less than the “second dimension” in a 2D case, or <code>length(Y) - 1</code> for a 1D vector.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/ed6acd68d0a251f2c0b0c2028b6c5e197a8a98ee/src/types/data.jl#L42-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.QKModel" href="#QuadraticKalman.QKModel"><code>QuadraticKalman.QKModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QKModel{T&lt;:Real, T2&lt;:Real}</code></pre><p>Main structure containing all parameters and moments needed for the quadratic Kalman filter.</p><p>This composite model encapsulates every component necessary to specify a quadratic state-space model. It bundles together the standard state evolution parameters, measurement parameters with quadratic terms, augmented state parameters for richer dynamics, and the unconditional moments that summarize the state behavior over time. This design enables integrated filtering and smoothing procedures within a unified framework.</p><p><strong>Fields</strong></p><ul><li><code>state::StateParams{T}</code>: Parameters governing the state process, defined by the equation X<em>t = μ + Φ X</em>{t-1} + Ω ε<em>t, where μ is the initial state mean, Φ is the state transition matrix, and Ω scales the process noise ε</em>t.</li><li><code>meas::MeasParams{T}</code>: Parameters for the measurement model, given by Y<em>t = A + B X</em>t + α Y<em>{t-1} + ∑</em>{i=1}^M (X<em>t&#39; C</em>i X<em>t) + D ε</em>t, including the intercept A, linear loading B, autoregressive term α, quadratic terms involving matrices C_i, and the measurement noise scaling D.</li><li><code>aug_state::AugStateParams{T,T2}</code>: Parameters for the augmented state space which extend the state representation. This component includes transformed state means, transitions, and additional matrices that capture nonlinear or auxiliary features of the state process. The use of a secondary numeric type T2 facilitates compatibility with automatic differentiation.</li><li><code>moments::Moments{T}</code>: The unconditional (or stationary) moments of both the state and the augmented state. This includes the long-run mean and covariance for the state dynamics as well as the augmented state, which are critical for initialization and diagnostic evaluation of the model.</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>T</code>: The primary numeric type used for most parameters (e.g., Float64). It must be a subtype of Real, ensuring both numerical precision and compatibility with standard arithmetic operations.</li><li><code>T2</code>: A potentially different numeric type used specifically for parameters like Lambda in AugStateParams, often employed to leverage automatic differentiation (AD) techniques.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/ed6acd68d0a251f2c0b0c2028b6c5e197a8a98ee/src/types/parameters.jl#L331-L351">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.StateParams" href="#QuadraticKalman.StateParams"><code>QuadraticKalman.StateParams</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">StateParams{T&lt;:Real}</code></pre><p>A structure representing the parameters that govern the evolution of the state in a state-space model. This type encapsulates the fundamental components required to describe the behavior of the state process, including its initial mean, transition dynamics, noise characteristics, and the resulting covariance.</p><p><strong>Fields</strong></p><ul><li>N::Int   The dimensionality of the state vector. This parameter specifies the number of state variables.</li><li>mu::AbstractVector{T}   The initial state mean vector. It must have a length equal to N.</li><li>Phi::AbstractMatrix{T}   The state transition matrix, which models how the state evolves over time. This matrix should be of size N×N.</li><li>Omega::AbstractMatrix{T}   The state noise matrix, used to scale the impact of the stochastic noise on the state evolution. It must be of size N×N.</li><li>Sigma::AbstractMatrix{T}   The state covariance matrix, typically computed as Omega * Omega&#39;. This matrix quantifies the uncertainty in the state.</li></ul><p><strong>Details</strong></p><p>The state evolution of a typical state-space model is represented by the equation:     Xₜ = mu + Phi * Xₜ₋₁ + Omega * εₜ, where εₜ represents a white noise process. This structure is a critical component in facilitating both the filtering and smoothing processes within the QuadraticKalman framework, ensuring that the model&#39;s dynamics are accurately captured and that its stability conditions can be properly validated.</p><p>This structure is also designed to integrate smoothly with automatic differentiation tools, taking advantage of Julia&#39;s type system to provide both precision and performance in numerical computations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/ed6acd68d0a251f2c0b0c2028b6c5e197a8a98ee/src/types/parameters.jl#L1-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.MeasParams" href="#QuadraticKalman.MeasParams"><code>QuadraticKalman.MeasParams</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MeasParams{T&lt;:Real}</code></pre><p>A container for the measurement equation parameters in a quadratic state-space model.</p><p>This structure holds all measurement-related parameters essential for specifying the measurement equation:</p><p>Yₜ = A + B * Xₜ + α * Yₜ₋₁ + ∑₍ᵢ₌₁₎ᴹ (Xₜ&#39; * Cᵢ * Xₜ) + noise</p><p>where:   • M: The number of measurement variables.   • A: A vector of intercept terms (length M).   • B: An M×N matrix mapping the state vector (of dimension N) to the measurement space.   • C: A vector of M matrices, each of size N×N, representing quadratic measurement parameters.   • D: An M×M matrix scaling the measurement noise.   • α: An M×M matrix capturing the autoregressive component in the measurement equation.   • V: An auxiliary M×M matrix computed as V = D * D&#39;, representing the covariance structure of the measurement noise.</p><p>All fields should be provided as concrete matrices or vectors (or will be derived from UniformScaling objects as needed), ensuring consistency and compatibility with downstream filtering and smoothing routines. The use of the @with_kw macro facilitates clear initialization and automatic field assignment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/ed6acd68d0a251f2c0b0c2028b6c5e197a8a98ee/src/types/parameters.jl#L97-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.Moments" href="#QuadraticKalman.Moments"><code>QuadraticKalman.Moments</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Moments{T&lt;:Real}</code></pre><p>Unconditional Moments Structure for the Quadratic Kalman Filter.</p><p>This structure encapsulates the long-run (stationary) moments of both the state and the augmented state. These moments include the mean and covariance estimates, which are critical for initializing the filter and for conducting diagnostic evaluations of the model dynamics.</p><p>Fields:</p><ul><li>state_mean::AbstractVector{T}: Unconditional (stationary) mean vector of the state.</li><li>state_cov::AbstractMatrix{T}: Unconditional covariance matrix of the state.</li><li>aug_mean::AbstractVector{T}: Unconditional mean vector of the augmented state.</li><li>aug_cov::AbstractMatrix{T}: Unconditional covariance matrix of the augmented state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/ed6acd68d0a251f2c0b0c2028b6c5e197a8a98ee/src/types/parameters.jl#L296-L311">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.AugStateParams" href="#QuadraticKalman.AugStateParams"><code>QuadraticKalman.AugStateParams</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AugStateParams{T&lt;:Real, T2&lt;:Real}</code></pre><p>An augmented state parameter container designed for quadratic measurement models. This type extends the conventional state-space representation to incorporate quadratic measurement features, enabling advanced filtering and smoothing algorithms to effectively handle non-linear measurement equations.</p><p>Fields:</p><ul><li>mu_aug::AbstractVector{T}:   The augmented state mean vector, which integrates the original state mean with additional terms arising from quadratic components.</li><li>Phi_aug::AbstractMatrix{T}:   The augmented state transition matrix. It extends the traditional state transition dynamics to include quadratic interactions.</li><li>B_aug::AbstractMatrix{T}:   The augmented measurement matrix that relates the extended state vector to the observed measurements, accounting for both linear and quadratic effects.</li><li>H_aug::AbstractMatrix{T}:   The augmented selection matrix used in mapping the original state space to the augmented space, facilitating the extraction of relevant subcomponents.</li><li>G_aug::AbstractMatrix{T}:   The augmented duplication matrix, which assists in preserving the symmetry properties of quadratic forms when processing covariance or moment adjustments.</li><li>Lambda::AbstractMatrix{T2}:   A core structural matrix that captures the key quadratic interactions within the model. Its specific formulation supports the reconstruction of quadratic measures.</li><li>L1::AbstractMatrix{T}:   An auxiliary matrix used for computing first-order moment corrections in the augmented state representation.</li><li>L2::AbstractMatrix{T}:   An auxiliary matrix involved in the computation of second-order moment adjustments, contributing to the accurate determination of state covariances.</li><li>L3::AbstractMatrix{T}:   An auxiliary matrix designed to support higher-order moment computations, often necessary for fine-tuning the filtering process.</li><li>P::Int:   The total augmented state dimension, typically defined as the sum of the original state dimension and the square of the state dimension.</li></ul><p>This structure is pivotal for models that incorporate quadratic measurement equations, allowing for the direct integration of quadratic terms into the state estimation process. It facilitates the derivation of augmented transition and measurement matrices, which are essential for achieving improved filtering and smoothing performance in non-linear state-space models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/ed6acd68d0a251f2c0b0c2028b6c5e197a8a98ee/src/types/parameters.jl#L181-L209">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.QKFOutput" href="#QuadraticKalman.QKFOutput"><code>QuadraticKalman.QKFOutput</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QKFOutput{T&lt;:Real}</code></pre><p>Combined container for both filtering and smoothing outputs from the Quadratic Kalman algorithm.</p><p>This type encapsulates the results of the forward filtering pass—where state estimates and associated covariances are computed recursively based solely on past and present observations—and the subsequent backward smoothing pass that refines these estimates by incorporating future observations. The unified structure provides a clear and convenient interface for diagnostic analysis, visualization, and further model-based inference tasks.</p><p><strong>Fields</strong></p><ul><li><code>filter::FilterOutput{T}</code>: Contains the outputs of the filtering process, such as the filtered log-likelihood, state estimates, and covariance matrices at each time step. These results represent the model’s estimates obtained in real time as the data was observed.</li><li><code>smoother::SmootherOutput{T}</code>: Contains the outputs of the smoothing process, which refines and improves upon the filter results by leveraging information from the entire observation sequence. This typically includes the smoothed state estimates and corresponding covariance matrices, providing a more accurate reconstruction of the underlying state dynamics.</li></ul><p><strong>Details</strong></p><p>Using the QKFOutput structure, users can conveniently access both the instantaneous (filtering) and retrospectively improved (smoothing) estimates, making it easier to perform post-hoc analysis, diagnostics, or forecasting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/ed6acd68d0a251f2c0b0c2028b6c5e197a8a98ee/src/types/outputs.jl#L122-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.FilterOutput" href="#QuadraticKalman.FilterOutput"><code>QuadraticKalman.FilterOutput</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FilterOutput{T&lt;:Real}</code></pre><p>A container for the outputs produced by the Quadratic Kalman Filter applied to state-space models with quadratic measurement equations. This structure organizes and stores all key filtering results, facilitating subsequent analysis, diagnostics, or visualization. </p><p>Fields:   • ll<em>t::Vector{T}        A vector containing the log-likelihood values computed at each time step.   • Z</em>tt::Matrix{T}        A matrix representing the filtered state estimates at the current time step.   • P<em>tt::Array{T,3}        A 3-dimensional array containing the error covariance matrices corresponding to the filtered state estimates.   • Y</em>ttm1::Union{Vector{T}, Matrix{T}}       The one-step-ahead (t-1) predicted measurements; it can be a vector for univariate cases or a matrix for multivariate cases.   • M<em>ttm1::Array{T,3}        A 3-dimensional array holding auxiliary statistics from the filtering process.   • K</em>t::Array{T,3}        A 3-dimensional array of Kalman gain matrices computed at each filter update.   • Z<em>ttm1::Matrix{T}        A matrix of the one-step-ahead state predictions (prior estimates).   • P</em>ttm1::Array{T,3}        A 3-dimensional array representing the error covariance matrices for the one-step-ahead state predictions.</p><p>Usage:     This structure is used to encapsulate all relevant outputs from the Quadratic Kalman Filter, ensuring that users can easily access and work with the filtered estimates, prediction errors, and associated metrics that describe the performance of the filtering process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/ed6acd68d0a251f2c0b0c2028b6c5e197a8a98ee/src/types/outputs.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.SmootherOutput" href="#QuadraticKalman.SmootherOutput"><code>QuadraticKalman.SmootherOutput</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SmootherOutput{T&lt;:Real}</code></pre><p>Container for outputs from the Quadratic Kalman Smoother. This structure encapsulates the results produced by the smoothing algorithm, which refines state estimates by incorporating information from both past and future observations. The smoother typically yields more accurate state estimates and associated uncertainty quantification than the filter alone.</p><p><strong>Fields</strong></p><ul><li><code>Z_smooth::Matrix{T}</code>: A matrix containing the smoothed state estimates. The matrix dimensions are P × (T̄+1), where P represents the dimension of the state vector and T̄+1 denotes the number of time steps.</li><li><code>P_smooth::Array{T,3}</code>: A three-dimensional array holding the smoothed covariance matrices. Each slice P_smooth[:, :, t] corresponds to the covariance estimate for the state at time step t, with overall dimensions P × P × (T̄+1).</li></ul><p><strong>Details</strong></p><p>The smoothed states and covariances are calculated using the Quadratic Kalman Smoother, which enhances the filtering results by backward recursion. This allows for improved state estimation by considering future as well as past measurements. The structure is essential for diagnostic checks and subsequent analyses in applications where state estimation uncertainty plays a critical role.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/ed6acd68d0a251f2c0b0c2028b6c5e197a8a98ee/src/types/outputs.jl#L89-L100">source</a></section></article><h3 id="Plotting-Types"><a class="docs-heading-anchor" href="#Plotting-Types">Plotting Types</a><a id="Plotting-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-Types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.KalmanFilterTruthPlot" href="#QuadraticKalman.KalmanFilterTruthPlot"><code>QuadraticKalman.KalmanFilterTruthPlot</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KalmanFilterTruthPlot{T,M&lt;:FilterOutput{&lt;:Real}}</code></pre><p>A type for plotting Kalman filter results against true states.</p><p><strong>Fields</strong></p><ul><li><code>true_states::T</code>: The true state values to compare against</li><li><code>results::M</code>: The output from running the Kalman filter (<code>FilterOutput</code>)</li></ul><p>This type is used internally by the plotting recipes to create comparison plots between the true states and the Kalman filter estimates, including confidence intervals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/ed6acd68d0a251f2c0b0c2028b6c5e197a8a98ee/src/plotting/recipes.jl#L26-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.KalmanSmootherTruthPlot" href="#QuadraticKalman.KalmanSmootherTruthPlot"><code>QuadraticKalman.KalmanSmootherTruthPlot</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KalmanSmootherTruthPlot{T,M&lt;:SmootherOutput{&lt;:Real}}</code></pre><p>A type for plotting Kalman smoother results against true states.</p><p><strong>Fields</strong></p><ul><li><code>true_states::T</code>: An <code>N×T_bar</code> matrix representing the actual underlying state values, <code>X_t</code>, that the model is attempting to filter. Each column corresponds to the state at a specific time step.</li><li><code>results::M</code>: The output from running the Kalman smoother, provided as a <code>SmootherOutput</code>, which includes the smoothed state estimates and associated covariance matrices.</li></ul><p>This type is used internally by the plotting recipes to create comparison plots between the true states and the Kalman smoother estimates. The plots typically display:</p><ul><li>The true state trajectories (as represented by the <code>N×T_bar</code> matrix of <code>X_t</code> values).</li><li>The smoother’s state estimates along with confidence intervals,</li></ul><p>thus facilitating a visual diagnostic of the smoother&#39;s performance in recovering the true state dynamics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/ed6acd68d0a251f2c0b0c2028b6c5e197a8a98ee/src/plotting/recipes.jl#L44-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.KalmanFilterPlot" href="#QuadraticKalman.KalmanFilterPlot"><code>QuadraticKalman.KalmanFilterPlot</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KalmanFilterPlot{M&lt;:FilterOutput{&lt;:Real}}</code></pre><p>An abstraction for constructing detailed visualizations of Kalman filter outcomes. This type is designed to encapsulate all necessary components for plotting the evolution of state estimates, along with the corresponding uncertainty measures, over time. It serves as a central piece within the plotting recipes framework, enabling users to create diagnostic graphics that compare filtered state trajectories against observed data, thereby providing deep insights into the performance and reliability of the Kalman filter.</p><p><strong>Fields</strong></p><ul><li><code>results::M</code>: The filtering results computed from a Kalman filter run, expected to be an instance of <code>FilterOutput</code>. This container typically includes:<ul><li>Filtered state estimates (<code>Z_tt</code>): The real-time estimates of the states.</li><li>Covariance matrices (<code>P_tt</code>): The corresponding error covariances associated with the state estimates.</li><li>Log-likelihood values (<code>ll_t</code>): Metrics that indicate the goodness-of-fit at each time step.</li><li>Supplementary outputs such as one-step-ahead predictions and other auxiliary statistics necessary for an in-depth analysis of the filtering process.</li></ul></li></ul><p><strong>Details</strong></p><p>This type is intended for internal use by the plotting recipes module to standardize and streamline the visualization process. Its role is to facilitate the generation of clear and informative plots that not only display the state estimates but also visually represent the associated uncertainty through confidence intervals. This makes it easier to assess the dynamic behavior of the filter, detect potential issues, and diagnose problems related to model fit and convergence.</p><p>The comprehensive documentation provided here ensures that users extending or interfacing with the plotting system will have a complete understanding of the type&#39;s purpose and structure, thereby enhancing the overall diagnostic workflow.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/ed6acd68d0a251f2c0b0c2028b6c5e197a8a98ee/src/plotting/recipes.jl#L64-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.KalmanSmootherPlot" href="#QuadraticKalman.KalmanSmootherPlot"><code>QuadraticKalman.KalmanSmootherPlot</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KalmanSmootherPlot{M&lt;:SmootherOutput{&lt;:Real}}</code></pre><p>A container for generating visualizations of Kalman smoother outputs. This type encapsulates the results of the smoother, which typically include smoothed state estimates and the corresponding covariance matrices, providing a unified interface for plotting these outputs along with their confidence intervals.</p><p><strong>Fields</strong></p><ul><li><code>results::M</code>: An instance of <code>SmootherOutput</code> that contains:<ul><li><code>Z_smooth</code>: A matrix of the smoothed state estimates.</li><li><code>P_smooth</code>: A three-dimensional array of the smoothed state covariances.</li></ul>These outputs are generated by executing a backward recursion that refines state estimates using future information.</li></ul><p><strong>Usage</strong></p><p>This type is used internally by the plotting recipes to produce diagnostic plots that display the smoother’s performance. The standard visualizations enable users to visually compare the smoothed state trajectories against true state values (or other benchmarks), with uncertainty represented as confidence intervals. This facilitates a detailed analysis of the model’s estimation efficiency and convergence properties.</p><p><strong>Details</strong></p><p>By encapsulating the smoother results, <code>KalmanSmootherPlot</code> simplifies the integration of smoothing diagnostics into the plotting framework. The associated plots typically illustrate:</p><ul><li>The estimated state trajectories over time.</li><li>The uncertainty in these estimates, often depicted using shaded regions corresponding to a 95% confidence interval.</li></ul><p>This enhanced visualization aids in assessing the accuracy and reliability of the smoothing procedure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/ed6acd68d0a251f2c0b0c2028b6c5e197a8a98ee/src/plotting/recipes.jl#L85-L110">source</a></section></article><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><h3 id="Filtering-and-Smoothing"><a class="docs-heading-anchor" href="#Filtering-and-Smoothing">Filtering and Smoothing</a><a id="Filtering-and-Smoothing-1"></a><a class="docs-heading-anchor-permalink" href="#Filtering-and-Smoothing" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.qkf_filter" href="#QuadraticKalman.qkf_filter"><code>QuadraticKalman.qkf_filter</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qkf_filter(data::QKData{T1,1}, model::QKModel{T,T2})</code></pre><p>Run the <strong>Quadratic Kalman Filter (QKF)</strong> on a time series of length <code>T̄</code>,  returning a new set of result arrays (out-of-place).</p><p><strong>Description</strong></p><p>This function implements the same <em>quadratic</em> Kalman filter recursion  as <code>qkf_filter!</code>, but instead of updating arrays in-place, it allocates  new arrays for predictions, updates, and outputs. This can be simpler to  use in contexts where you don&#39;t want to mutate or reuse <code>data</code> and <code>model</code>,  but it may be less memory-efficient for large-scale problems.</p><p>At each time step, it performs:</p><ol><li><strong>State Prediction</strong> (<code>predict_Z_tt</code> / <code>predict_P_tt</code>)</li><li><strong>Measurement Prediction</strong> (<code>predict_Y_tt</code> / <code>predict_M_ttm1</code>)</li><li><strong>Kalman Gain Computation</strong> (<code>compute_K_t</code>)</li><li><strong>State &amp; Covariance Update</strong> (<code>update_Z_tt</code>, <code>update_P_tt</code>)</li><li><strong>PSD Correction</strong> (<code>correct_Zₜₜ</code>)</li><li><strong>Log-Likelihood</strong> computation.</li></ol><p><strong>Arguments</strong></p><ul><li><code>data::QKData{T1,1}</code>   Same structure as in <code>qkf_filter!</code>, with fields:<ul><li><code>Y::Vector{T1}</code>, <code>T̄::Int</code>, <code>M::Int</code>.</li></ul></li><li><code>model::QKModel{T,T2}</code>   Same parameter structure as in <code>qkf_filter!</code>, with fields:<ul><li><code>N::Int</code>, <code>P::Int</code>, <code>μ̃ᵘ, Σ̃ᵘ</code>, etc.</li></ul></li></ul><p><strong>Return</strong></p><p>A named tuple with fields:</p><ul><li><code>ll_t::Vector{Float64}</code>   Per-time-step log-likelihoods (size = <code>T̄</code>).</li><li><code>Z_tt::Array{T,3}</code>   The filtered state at each time step (dimensions <code>(T, P, T̄+1)</code> in your usage).</li><li><code>P_tt::Array{T,4}</code>   The filtered state covariance array.</li><li><code>Y_ttm1::Vector{T}</code>   Predicted measurement for each step.</li><li><code>M_ttm1::Array{T,4}</code>   Predicted measurement covariances.</li><li><code>K_t::Array{T,4}</code>   The Kalman gain for each time step.</li><li><code>Z_ttm1::Array{T,3}</code>   One-step-ahead predicted states.</li><li><code>P_ttm1::Array{T,4}</code>   One-step-ahead predicted covariances.</li></ul><p><strong>Details</strong></p><ol><li><strong>Initialization</strong>:<ul><li>Creates new arrays for <code>Z_tt</code> and <code>P_tt</code> and sets the initial state  to <code>aug_mean</code> and <code>aug_cov</code>.</li></ul></li><li><strong>Time Loop</strong>: <ul><li><strong>Prediction</strong>: <code>predict_Z_tt</code>, <code>predict_P_tt</code>.</li><li><strong>Measurement</strong>: <code>predict_Y_tt</code>, <code>predict_M_ttm1</code>.</li><li><strong>Gain &amp; Update</strong>: <code>compute_K_t</code>, <code>update_Z_tt</code>, <code>update_P_tt</code>.</li><li><strong>Correction</strong>: <code>correct_Z_tt</code> for PSD.</li><li><strong>Likelihood</strong>: <code>compute_loglik</code>.</li></ul></li><li><strong>No In-Place Mutation</strong>:<ul><li>Each step returns fresh arrays; original inputs are not modified.</li></ul></li></ol><p><strong>Example</strong></p><pre><code class="language-julia hljs">data = QKData(Y, M=measurement_dim, T̄=length(Y)-1)
model = QKModel(...)
result = qkf_filter(data, model)

@show result.ll_t
@show result.Z_tt[:, end]   # final state</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/ed6acd68d0a251f2c0b0c2028b6c5e197a8a98ee/src/core/filter.jl#L1053-L1130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.qkf_filter!" href="#QuadraticKalman.qkf_filter!"><code>QuadraticKalman.qkf_filter!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qkf_filter!(data::QKData{T1,1}, model::QKModel{T,T2})</code></pre><p>Run the <strong>Quadratic Kalman Filter (QKF)</strong> on a time series of length <code>T̄</code>, modifying the result in-place.</p><p><strong>Description</strong></p><p>This function implements a Kalman-like recursive filter where the state  vector <code>Zₜ</code> includes not only the usual mean component <code>xₜ</code> but also  terms for the second-moment <code>(x xᵀ)ₜ</code>, making it a <em>quadratic</em> extension.  At each time step, it performs:</p><ol><li><strong>State Prediction</strong> (<code>predict_Z_ttm1!</code> / <code>predict_P_ttm1!</code>)</li><li><strong>Measurement Prediction</strong> (<code>predict_Y_ttm1!</code> / <code>predict_M_ttm1!</code>)</li><li><strong>Kalman Gain Computation</strong> (<code>compute_K_t!</code>)</li><li><strong>State &amp; Covariance Update</strong> (<code>update_Z_tt!</code>, <code>update_P_tt!</code>)</li><li><strong>PSD Correction</strong> (<code>correct_Z_tt!</code>)</li><li><strong>Log-Likelihood</strong> computation for the current innovation.</li></ol><p>Unlike the non-mutating version (<code>qkf_filter</code>), this function reuses  and mutates internal arrays and data structures in-place, which can  improve performance and reduce memory allocations.</p><p><strong>Arguments</strong></p><ul><li><p><code>data::QKData{T1,1}</code>   A structure holding:</p><ul><li><code>Y::Vector{T1}</code> of length <code>T̄+1</code>, containing observations.  Typically, <code>Y[1]</code> is an initial placeholder and <code>Y[2..end]</code>  are the actual measurements.</li><li><code>T_bar::Int</code> the total number of time steps (excluding index 0).</li><li><code>M::Int</code> the dimension of the measurement at each time step.</li></ul></li><li><p><code>model::QKModel{T,T2}</code>   A parameter structure holding:</p><ul><li><code>N::Int</code>: State dimension (for the mean part).</li><li><code>P::Int</code>: Dimension of the augmented &quot;quadratic&quot; state  (<code>P = N + N(N+1)/2</code>).</li><li><code>μ_aug, Σ_aug</code>: The unconditional mean and covariance used for  initialization.</li><li>Additional model matrices or functions (e.g., <code>Φ_aug</code>, <code>B_aug</code>, <code>A</code>, <code>V</code>)  accessed via subroutines.</li></ul></li></ul><p><strong>Return</strong></p><p>A named tuple with fields:</p><ul><li><code>ll_t::Vector{Float64}</code>   The per-time-step log-likelihoods (size = <code>T̄</code>).</li><li><code>Z_tt::Array{T,3}</code>   The filtered state at each time step. Dimensions: <code>(T, P, T̄+1)</code> in your  specific code (or <code>(P, T̄+1)</code> in a more generic version).</li><li><code>Pₜₜ::Array{T,4}</code>   The filtered state covariance array. Dimensions often <code>(T, P, P, T̄+1)</code>  in your code.</li><li><code>Yₜₜ₋₁::Vector{T}</code>   The predicted measurement at each time step (size = <code>T̄</code>).</li><li><code>M_ttm1::Array{T,4}</code>   The predicted measurement covariance, dimensions <code>(T, M, M, T̄)</code>.</li><li><code>K_t::Array{T,4}</code>   The Kalman gain for each time step, <code>(T, P, M, T̄)</code>.</li><li><code>Zₜₜ₋₁::Array{T,3}</code>   One-step-ahead predicted states.</li><li><code>Pₜₜ₋₁::Array{T,4}</code>   One-step-ahead predicted covariances.</li><li><code>Σ_ttm1::Array{T,4}</code>   Any intermediate covariance terms used for prediction.</li></ul><p><strong>Details</strong></p><ol><li><strong>Initialization</strong>: <ul><li><code>Z_tt[:, 1] .= μ̃ᵘ</code> and <code>P_tt[:,:,1] .= Σ̃ᵘ</code>.</li></ul></li><li><strong>Recursive Steps</strong> (<code>for t in 1:T̄</code>):<ul><li><strong>Prediction</strong>: <code>predict_Z_ttm1!</code> / <code>predict_P_ttm1!</code>.</li><li><strong>Measurement</strong>: <code>predict_Y_ttm1!</code> / <code>predict_M_ttm1!</code>.</li><li><strong>Gain &amp; Update</strong>: <code>compute_K_t!</code>, then <code>update_Z_tt!</code> / <code>update_P_tt!</code>. </li><li><strong>Correction</strong>: <code>correct_Z_tt!</code> clamps negative eigenvalues  for PSD.</li><li><strong>Likelihood</strong>: <code>compute_loglik!</code> appends the log-likelihood.</li></ul></li><li><strong>Positive Semidefinite Correction</strong>: <ul><li>Negative eigenvalues introduced by approximation are set to zero.</li></ul></li></ol><p><strong>Example</strong></p><pre><code class="language-julia hljs">data = QKData(Y, M=measurement_dim, T̄=length(Y)-1)
model = QKModel(...)
result = qkf_filter!(data, model)

@show result.ll_t
@show result.Z_tt[:, end]   # final state</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/ed6acd68d0a251f2c0b0c2028b6c5e197a8a98ee/src/core/filter.jl#L895-L989">source</a></section><section><div><pre><code class="language-julia hljs">qkf_filter!(data::QKData{T1,1}, model::QKModel{T,T2})</code></pre><p>Run the <strong>Quadratic Kalman Filter (QKF)</strong> on a time series of length <code>T̄</code>.</p><p><strong>Description</strong></p><p>This function implements a Kalman-like recursive filter where the state  vector <code>Z_t</code> includes not only the usual mean component <code>xₜ</code> but also  terms for the second-moment <code>(x xᵀ)ₜ</code>, making it a <em>quadratic</em> extension.  At each time step, it performs:</p><ol><li><strong>State Prediction</strong> (<code>predict_Z_ttm1</code> / <code>predict_P_ttm1</code>)</li><li><strong>Measurement Prediction</strong> (<code>predict_Y_ttm1</code> / <code>predict_M_ttm1</code>)</li><li><strong>Kalman Gain Computation</strong> (<code>compute_K_t</code>)</li><li><strong>State &amp; Covariance Update</strong> (<code>update_Zₜₜ!</code>, <code>update_Pₜₜ!</code>)</li><li><strong>PSD Correction</strong>: Ensures the implied covariance is positive semidefinite  by clamping negative eigenvalues via <code>correct_Zₜₜ!</code>.</li><li><strong>Log-Likelihood</strong> computation for the current innovation.</li></ol><p>The filter stores and returns the entire history of filtered states, covariances, predicted measurements, and related arrays. </p><p><strong>Arguments</strong></p><ul><li><p><code>data::QKData{T1,1}</code>   A structure holding:</p><ul><li><code>Y::Vector{T1}</code> of length <code>T_bar+1</code>, which contains observations  (<code>Y[1]</code> is unused or some initial placeholder, and <code>Y[2..end]</code> are the actual measurements).</li><li><code>T_bar::Int</code> the total number of time steps (excluding index 0).</li><li><code>M::Int</code> the dimension of the measurement at each time step.</li></ul></li><li><p><code>model::QKModel{T,T2}</code>   A parameter structure holding:</p><ul><li><code>N::Int</code>: State dimension (for the mean part).</li><li><code>P::Int</code>: Dimension of the augmented &quot;quadratic&quot; state vector  (<code>P = N + N(N+1)/2</code>).</li><li><code>aug_mean, aug_cov</code>: The unconditional mean and covariance used for initialization.</li><li>Additional model matrices or functions (e.g., <code>Phi_aug</code>, <code>B_aug</code>, <code>A</code>, <code>V</code>),  typically accessed via separate predict/update subroutines.</li></ul></li></ul><p><strong>Return</strong></p><p>A named tuple with fields:</p><ul><li><p><code>ll_t::Vector{Float64}</code>   The per-time-step log-likelihoods of the innovations (size = <code>T_bar</code>).</p></li><li><p><code>Z_tt::Matrix{T}</code>   The updated (&quot;filtered&quot;) state at each time step. Dimensions: <code>(P, T_bar+1)</code>,  where column <code>k</code> corresponds to time index <code>k-1</code>.</p></li><li><p><code>P_tt::Array{T,3}</code>   The updated (&quot;filtered&quot;) state covariance array (or the augmented second-moment  representation) at each time step. Dimensions: <code>(P, P, T_bar+1</code>.</p></li><li><p><code>Y_ttm1::Vector{T}</code>   The predicted measurement at each time step (size = <code>T_bar</code>).</p></li><li><p><code>M_ttm1::Array{T,3}</code>   The predicted measurement covariance at each time step (dimensions: <code>(M, M, T_bar)</code>).</p></li><li><p><code>K_t::Array{T,3}</code>   The Kalman gain at each time step <code>(P, M, T_bar)</code>.</p></li><li><p><code>Z_ttm1::Matrix{T}</code>   The one-step-ahead predicted state (dimensions: <code>(P, T_bar)</code>).</p></li><li><p><code>P_ttm1::Array{T,4}</code>   The one-step-ahead predicted covariance (dimensions: <code>(P, P, T_bar)</code>).</p></li><li><p><code>Σ_ttm1::Array{T,4}</code>   Any intermediate state-dependent covariance terms added during prediction  (dimensions: <code>(P, P, T_bar)</code>).</p></li></ul><p><strong>Details</strong></p><ol><li><p><strong>Initialization</strong>:  </p><ul><li><code>Z_tt[:,1] .= aug_mean</code> and <code>P_tt[:,:,1] .= aug_cov</code>, representing the state at time 0.</li></ul></li><li><p><strong>Time Loop</strong> (<code>for t in 1:T_bar</code>):  </p><ul><li><strong>Predict</strong> step: <ul><li><code>predict_Z_ttm1</code> sets <code>Z_ttm1[:,t]</code> from <code>Z_tt[:,t]</code>.</li><li><code>predict_P_ttm1</code> sets <code>P_ttm1[:,:,t]</code> from <code>P_tt[:,:,t]</code>.</li></ul></li><li><strong>Measurement</strong> step: <ul><li><code>predict_Y_ttm1</code> computes <code>Y_ttm1[t]</code> from <code>Z_ttm1[:,t]</code>.</li><li><code>predict_M_ttm1</code> updates <code>M_ttm1[:,:,t]</code>.</li></ul></li><li><strong>Gain &amp; Update</strong>:<ul><li><code>compute_K_t</code> obtains the Kalman gain <code>K_t[:,:,t]</code>.</li><li><code>update_Z_tt</code> and <code>update_P_tt</code> yield the next <code>Z_tt[:,t+1]</code> and <code>P_tt[:,:,t+1]</code>.</li></ul></li><li><strong>Correction</strong>:  <ul><li><code>correct_Z_tt</code> clamps negative eigenvalues in the implied covariance portion  of <code>Z_tt</code> to ensure PSD. </li></ul></li><li><strong>Likelihood</strong>:<ul><li><code>compute_loglik</code> appends/logs the innovation-based log-likelihood  in <code>ll_t[t]</code>.</li></ul></li></ul></li><li><p><strong>Positive Semidefinite Correction</strong>:</p><ul><li>Because the filter tracks <code>[X Xᵀ] - X Xᵀᵀ</code> as a covariance block, it can  become indefinite due to linearization or numerical issues. We enforce  PSD by zeroing out negative eigenvalues in <code>correct_Z_tt</code>.</li><li>This step is not strictly differentiable at eigenvalues crossing zero.  If you need AD through the filter, consider an alternative correction  or a custom adjoint.</li></ul></li></ol><p><strong>Example</strong></p><p>```julia data = QKData(Y, M=measurement<em>dim, T</em>bar=length(Y)-1) model = QKModel( ... )   # set up your model</p><p>result = qkf_filter!(data, model)</p><p>@show result.ll<em>t @show result.Z</em>tt[:, end]   # final state vector</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/ed6acd68d0a251f2c0b0c2028b6c5e197a8a98ee/src/core/filter.jl#L1183-L1298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.qkf_smoother" href="#QuadraticKalman.qkf_smoother"><code>QuadraticKalman.qkf_smoother</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qkf_smoother( Z, P, Z_pred, P_pred, T_bar, H_aug, G_aug, Φ_aug, dof ) -&gt; (Z_smooth, P_smooth)</code></pre><p>Out-of-place version of the QKF smoother. Returns new arrays rather than overwriting the input ones.</p><p><strong>Description</strong></p><p>Identical to qkf<em>smoother! in logic, but it allocates new arrays Z</em>smooth and P_smooth for the smoothed results. This is often simpler for AD frameworks that do not allow in-place mutation of arrays.</p><p><strong>Returns</strong></p><ul><li><code>Z_smooth::Matrix{T}</code>: (P × (T_bar+1)) smoothed states</li><li><code>P_smooth::Array{T,3}</code>: (P × P × (T_bar+1)) smoothed covariances</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">Z_smooth, P_smooth = qkf_smoother(Z, P, Z_pred, P_pred, T_bar, Hn, Gn, H_aug, Φ_aug, n)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/ed6acd68d0a251f2c0b0c2028b6c5e197a8a98ee/src/core/smoother.jl#L114-L133">source</a></section><section><div><pre><code class="language-julia hljs">qkf_smoother(filter_output::FilterOutput{T}, model::QKModel{T,T2}) where {T&lt;:Real, T2&lt;:Real}</code></pre><p>Performs out-of-place backward smoothing for the Quadratic Kalman Filter (QKF) using filtering outputs. This function refines the state estimates produced during filtering by incorporating future observations through a backward smoothing pass.</p><p><strong>Arguments</strong></p><ul><li>filter<em>output::FilterOutput{T}: A container holding the outputs from the filtering phase, including:   • Z</em>tt: A matrix of filtered augmented state estimates.   • P<em>tt: An array of filtered state covariances.   • Z</em>ttm1: A matrix containing the one-step-ahead predicted states.   • P_ttm1: An array containing the one-step-ahead predicted state covariances.</li><li>model::QKModel{T,T2}: A model specification that provides the necessary parameters for the smoothing process. The model includes an <code>aug_state</code> field which is unpacked to retrieve:   • H<em>aug: The augmented measurement selection matrix.   • G</em>aug: The augmented duplication matrix used for handling quadratic forms.   • Phi_aug: The augmented state transition matrix. Additionally, the <code>state</code> field is used to extract the dimensionality (N) of the state.</li></ul><p><strong>Details</strong></p><p>This function first creates copies of the filtered state and covariance estimates to prevent modification of the original filtering outputs. It then invokes the in-place smoother routine (<code>qkf_smoother!</code>) on these copies using the one-step-ahead predicted values and the model&#39;s parameters. The final smoothed results are wrapped in a <code>SmootherOutput</code> struct and returned as fresh copies, which is particularly important for compatibility with automatic differentiation (AD) workflows.</p><p><strong>Returns</strong></p><ul><li>SmootherOutput: A composite structure containing:   • Z<em>smooth: A matrix of smoothed augmented state estimates.   • P</em>smooth: An array of smoothed state covariance matrices.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/ed6acd68d0a251f2c0b0c2028b6c5e197a8a98ee/src/core/smoother.jl#L201-L232">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.qkf_smoother!" href="#QuadraticKalman.qkf_smoother!"><code>QuadraticKalman.qkf_smoother!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qkf_smoother!(
    Z::AbstractMatrix{T},      # Filtered states   (P × (T_bar+1))
    P::AbstractArray{T, 3},    # Filtered covariances (P × P × (T_bar+1))
    Z_pred::AbstractMatrix{T}, # One-step-ahead predicted states (P × T_bar)
    P_pred::AbstractArray{T,3},
    T_bar::Int,
    Hn::Matrix{T},  Gn::Matrix{T},  H_aug::Matrix{T},  Φ_aug::Matrix{T},
    dof::Int
) where {T&lt;:Real}</code></pre><p>Perform <strong>in-place</strong> backward smoothing for the Quadratic Kalman Filter (QKF).</p><p><strong>Description</strong></p><p>Given the forward-filtered estimates <code>(Z, P)</code> from <code>t=1..T_bar</code>, plus the  one-step-ahead predictions <code>(Z_pred, P_pred)</code> and the special matrices  (H<em>aug, G</em>aug) that handle the dimension reduction via  Vech(·)/Vec(·), this function computes <code>Z[:,t]</code> and <code>P[:,:,t]</code> for  <code>t = T_bar-1 .. 1</code> in backward fashion to produce the smoothed estimates  (Zₜ|T<em>bar, PZₜ|T</em>bar).  </p><p><strong>Mathematical Form (Backward Pass)</strong></p><ol><li><p>Compute   Fₜ = (H̃ₙPᵗ|ᵗᶻH̃ₙ&#39;)(H̃ₙΦ̃G̃ₙ)&#39;(H̃ₙPᵗ⁺¹|ᵗᶻH̃ₙ&#39;)⁻¹ but implemented via solves (rather than explicit inverses) for numerical stability.</p></li><li><p>Then update (in H̃ₙ-transformed space): H̃ₙZₜ|ₜ = H̃ₙZₜ|ₜ + Fₜ(H̃ₙZₜ₊₁|ₜ - H̃ₙZₜ₊₁|ₜ)</p></li><li><p>And similarly for the covariance: (H̃ₙPᵗ|ᵀᶻH̃ₙ&#39;) = (H̃ₙPᵗ|ᵗᶻH̃ₙ&#39;) + Fₜ[(H̃ₙPᵗ⁺¹|ᵀᶻH̃ₙ&#39;) - (H̃ₙPᵗ⁺¹|ᵗᶻH̃ₙ&#39;)]Fₜ&#39;</p></li><li><p>Finally, transform back to get <code>Zₜ|T</code> and <code>Pᵗ|ᵀᶻ</code> in the full (Vec/augmented) space if necessary.</p></li></ol><p><strong>Arguments</strong></p><ul><li><code>Z::AbstractMatrix{T}</code>: On entry, <code>Z[:,t]</code> = <code>Zₜ|T</code> for each <code>t</code>. On exit, it will contain the smoothed states <code>Zₜ|T</code>.</li><li><code>P::AbstractArray{T,3}</code>: On entry, <code>P[:,:,t]</code> = <code>Pᵗ|ᵀᶻ</code>.  On exit, <code>P[:,:,t]</code> = <code>Pᵗ|ᵀᶻ</code>.</li><li><code>Z_pred::AbstractMatrix{T}</code>, <code>P_pred::AbstractArray{T,3}</code>:  The one-step-ahead predicted states/covariances from the forward pass, i.e. <code>Z_pred[:,t] = Zₜ|ₜ</code>, <code>P_pred[:,:,t] = P^Zₜ|ₜ</code>.</li><li><code>T_bar::Int</code>: Total time steps (excluding time 0).</li><li><code>Hn::Matrix{T}</code>, <code>Gn::Matrix{T}</code>: The selection/duplication operators  for Vec/Vech transforms of block <code>(x xᵀ)</code>. Usually size <code>(n(n+1) × n(n+3)/2)</code> or similarly.</li><li><code>H_aug::Matrix{T}</code>, <code>Φ_aug::Matrix{T}</code>: The augmented versions  (H<em>aug, G</em>aug) used in the QKF recursion.</li><li><code>dof::Int</code>: Dimension parameter (often <code>n</code> or <code>P</code>). Adjust to your model.</li></ul><p><strong>Notes</strong></p><ul><li>This function runs backward from <code>t = T_bar-1</code> down to <code>t = 1</code>, using  the final values <code>(Z[:, T_bar], P[:,:, T_bar])</code> as the terminal condition  (<code>Z_{T_bar|T_bar}, P^Z_{T_bar|T_bar}</code>).</li><li>If your AD library supports destructive updates, this approach should  be AD-friendly; if not, consider the out-of-place version <code>qkf_smoother</code>.</li></ul><p><strong>Example</strong></p><p>Suppose you already ran the forward filter, so you have:     Z, P, Z<em>pred, P</em>pred, plus your special matrices.</p><pre><code class="nohighlight hljs">qkf_smoother!(Z, P, Z_pred, P_pred, T_bar, Hn, Gn, H_aug, Φ_aug, n)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/ed6acd68d0a251f2c0b0c2028b6c5e197a8a98ee/src/core/smoother.jl#L2-L69">source</a></section><section><div><pre><code class="language-julia hljs">qkf_smoother!(filter_output::FilterOutput{T}, model::QKModel{T,T2}) where {T&lt;:Real, T2&lt;:Real}</code></pre><p>Performs in-place backward smoothing for a Quadratic Kalman Filter (QKF) using the outputs obtained during filtering.</p><p>This function refines the filtered state estimates and covariance matrices by incorporating future observations, thereby producing a set of smoothed estimates. It operates by first extracting the filtered states (Z<em>tt) and their associated covariances (P</em>tt), as well as the one-step-ahead predictions (Z<em>ttm1 and P</em>ttm1) from the given FilterOutput structure. It then unpacks the augmented state parameters (H<em>aug, G</em>aug, Phi_aug) along with the state dimension (N) from the QKModel. The function makes local copies of the filtered estimates to avoid any modification of the original filtering results, and then calls the lower-level in-place smoothing routine to update these copies using the one-step-ahead predictions and the model parameters. The smoothed states and covariances are finally encapsulated into a SmootherOutput structure, which is returned.</p><p>Parameters:</p><ul><li>filter<em>output: A FilterOutput instance containing:   • Z</em>tt    :: Matrix of filtered augmented state estimates for time steps 0 to T̄.   • P<em>tt    :: Array of filtered state covariance matrices.   • Z</em>ttm1  :: Matrix of one-step-ahead predicted augmented states.   • P_ttm1  :: Array of one-step-ahead predicted covariance matrices.</li><li>model: A QKModel instance providing the necessary model parameters for smoothing, including:   • aug<em>state: A structure containing:       - H</em>aug  :: The augmented measurement selection matrix.       - G<em>aug  :: The augmented duplication matrix for handling quadratic forms.       - Phi</em>aug:: The augmented state transition matrix.   • state: The dimension (N) of the state vector.</li></ul><p>Returns:</p><ul><li>A SmootherOutput structure containing:   • Z<em>smooth :: Matrix of smoothed augmented state estimates.   • P</em>smooth :: Array of smoothed state covariance matrices.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/ed6acd68d0a251f2c0b0c2028b6c5e197a8a98ee/src/core/smoother.jl#L153-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.qkf" href="#QuadraticKalman.qkf"><code>QuadraticKalman.qkf</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qkf(model::QKModel{T,T2}, data::QKData{T1,N}) where {T1&lt;:Real, T&lt;:Real, T2&lt;:Real, N}</code></pre><p>Execute the full Quadratic Kalman Filter (QKF) process by combining both the filtering and backward smoothing stages. This function first applies the filtering routine to generate real-time state estimates and then refines these estimates using the smoother to incorporate information from future observations. The resulting output is a composite object that  encapsulates both the filtered and smoothed results.</p><p>Parameters:</p><ul><li>model::QKModel{T,T2}: A model specification that includes the system dynamics, state transition parameters, and the augmented state representation. This object provides all necessary configurations to perform the QKF.</li><li>data::QKData{T1,N}: A data container comprising the observed time series measurements, formatted appropriately for the QKF. The parameter N indicates the dimension of the state vector, and T1 denotes the numerical type of the data.</li></ul><p>Process:</p><ol><li>Filtering Stage: The function invokes qkf_filter with the provided data and model to compute the filtered state estimates and error covariances.</li><li>Smoothing Stage: It then calls qkf_smoother to perform backward smoothing on the filtered results, enhancing the  state estimates by leveraging future information.</li></ol><p>Returns:</p><ul><li>QKFOutput{T}: A composite output object that bundles both filtering and smoothing results. This output includes:   • filter<em>output: The results from the filtering phase, containing state estimates and covariances.   • smoother</em>output: The refined state estimates obtained after applying the smoother.</li></ul><p>This combined output is useful for subsequent analysis, diagnostics, and visualization of the QKF performance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/ed6acd68d0a251f2c0b0c2028b6c5e197a8a98ee/src/core/smoother.jl#L253-L278">source</a></section><section><div><pre><code class="language-julia hljs">qkf(data::QKData{T1,N}, model::QKModel{T,T2}) where {T1&lt;:Real, T&lt;:Real, T2&lt;:Real, N}</code></pre><p>This function offers a backwards-compatible interface to the Quadratic Kalman Filter (QKF) by accepting the data and model arguments in a reversed order compared to the standard interface. Typically, the preferred order is to pass the model first followed by the data. This method ensures that legacy code that follows the old argument order still functions correctly.</p><p>Parameters:</p><ul><li>data::QKData{T1,N}: An instance containing the observed time series data formatted for the QKF. The data structure organizes the measurements and any associated time indices to be processed by the filter.</li><li>model::QKModel{T,T2}: An instance containing the model specifications which include the system dynamics, the augmented state representation, and all relevant parameters required to perform the filtering and smoothing operations.</li></ul><p>Returns:</p><ul><li>QKFOutput{T}: A composite output object that includes both the filtering results and the smoothed state estimates. This output encapsulates all intermediate steps and final results computed by invoking the standard qkf function with the proper argument order.</li></ul><p>Note:    This reversed argument order function is maintained solely for backwards compatibility. Internally, it simply calls    qkf(model, data) to ensure that the original processing logic remains unchanged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/ed6acd68d0a251f2c0b0c2028b6c5e197a8a98ee/src/core/smoother.jl#L291-L312">source</a></section></article><h3 id="Convenience-Functions"><a class="docs-heading-anchor" href="#Convenience-Functions">Convenience Functions</a><a id="Convenience-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Convenience-Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.get_measurement" href="#QuadraticKalman.get_measurement"><code>QuadraticKalman.get_measurement</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_measurement(data::QKData{T,N}, t::Int) where {T&lt;:Real, N}</code></pre><p>Extract measurement at time t from QKData.  For vector data returns a scalar, for matrix data returns a vector.</p><p><strong>Arguments</strong></p><ul><li><code>data::QKData{T,N}</code>: Data structure</li><li><code>t::Int</code>: Time index (1-based)</li></ul><p><strong>Returns</strong></p><ul><li>For N=1: Single measurement Y[t]</li><li>For N=2: Vector of measurements Y[:,t]</li></ul><p><strong>Throws</strong></p><ul><li>ArgumentError if t is out of bounds</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/ed6acd68d0a251f2c0b0c2028b6c5e197a8a98ee/src/types/data.jl#L148-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.qkf_negloglik" href="#QuadraticKalman.qkf_negloglik"><code>QuadraticKalman.qkf_negloglik</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qkf_negloglik(params::Vector{T}, data::QKData, N::Int, M::Int) where T&lt;:Real -&gt; Real</code></pre><p>Compute the negative log-likelihood for a Quadratic Kalman Filter model given parameters and data.</p><p><strong>Arguments</strong></p><ul><li><code>params::Vector{T}</code>: Vector of model parameters to be converted into a QKModel</li><li><code>data::QKData</code>: Data container with observations and optional initial conditions</li><li><code>N::Int</code>: Dimension of the state vector</li><li><code>M::Int</code>: Dimension of the measurement vector</li></ul><p><strong>Returns</strong></p><p>The negative log-likelihood value computed by:</p><ol><li>Converting parameters to a QKModel</li><li>Running the Kalman filter</li><li>Taking the negative sum of the per-period log-likelihoods</li></ol><p><strong>Note</strong></p><p>This function is typically used as an objective function for maximum likelihood estimation, where the goal is to minimize the negative log-likelihood.</p><p>For optimization, you may want to wrap this function with N, M and data specified:</p><pre><code class="language-julia hljs">negloglik(params) = qkf_negloglik(params, data, N, M)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/ed6acd68d0a251f2c0b0c2028b6c5e197a8a98ee/src/core/likelihood.jl#L278-L305">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.model_to_params" href="#QuadraticKalman.model_to_params"><code>QuadraticKalman.model_to_params</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">model_to_params(model::QKModel{T, T2}) where {T&lt;:Real, T2}</code></pre><p>Convert a QKModel object into a vector of unconstrained parameters.</p><p>The ordering of the parameters is as follows:</p><ol><li><p><strong>State parameters:</strong></p><ul><li><code>mu</code> (length N)</li><li><code>Phi</code> (N×N, stored columnwise)</li><li>Unconstrained parameters for the state noise scaling factor Ω: For each row <code>i = 1,...,N</code> and column <code>j = 1,...,i</code> (i.e. the lower–triangular part):<ul><li>If <code>i == j</code>: the parameter is <code>log(Ω[i,i])</code></li><li>Else: the parameter is <code>Ω[i,j]</code></li></ul></li></ul></li><li><p><strong>Measurement parameters:</strong></p><ul><li><code>A</code> (length M)</li><li><code>B</code> (M×N, stored columnwise)</li><li><code>C</code> (a vector of M matrices; each matrix is N×N and is flattened columnwise)</li><li>Unconstrained parameters for the measurement noise scaling factor D: For each row <code>i = 1,...,M</code> and column <code>j = 1,...,i</code>:<ul><li>If <code>i == j</code>: the parameter is <code>log(D[i,i])</code></li><li>Else: the parameter is <code>D[i,j]</code></li></ul></li><li><code>alpha</code> (M×M, stored columnwise)</li></ul></li></ol><p><strong>Returns</strong></p><p>A vector of unconstrained parameters that, when passed to <code>params_to_model</code>, reconstructs the original QKModel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/ed6acd68d0a251f2c0b0c2028b6c5e197a8a98ee/src/types/parameters.jl#L606-L633">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.params_to_model" href="#QuadraticKalman.params_to_model"><code>QuadraticKalman.params_to_model</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">params_to_model(params::Vector{T}, N::Int, M::Int) where T&lt;:Real -&gt; QKModel</code></pre><p>Convert a parameter vector into a QKModel object with state and measurement parameters.</p><p><strong>Arguments</strong></p><ul><li><code>params::Vector{T}</code>: A vector of unconstrained parameters.</li><li><code>N::Int</code>: Dimension of the state vector.</li><li><code>M::Int</code>: Dimension of the measurement vector.</li></ul><p><strong>Returns</strong></p><p>A <code>QKModel</code> object containing:</p><ul><li><strong>State parameters:</strong> (mu, Phi, Omega)   where the state equation is     Xₜ = μ + Φ Xₜ₋₁ + Omega εₜ. Here, Omega is constructed as Omega = D<em>state * D</em>state′, with D_state a lower–triangular matrix (of size N×N) whose diagonal entries are positive.</li><li><strong>Measurement parameters:</strong> (A, B, C, D, α)   where the measurement equation is     Yₜ = A + B Xₜ + α Yₜ₋₁ + ∑₍ᵢ₌₁₎ᴹ Xₜ′ Cᵢ Xₜ + D εₜ. Here, D is constructed as D = D<em>meas * D</em>meas′, with D_meas a lower–triangular matrix (of size M×M) whose diagonal entries are positive.</li><li>Augmented state parameters and model moments (computed via helper functions).</li></ul><p><strong>Parameter vector layout</strong></p><p>The parameter vector is assumed to contain:</p><ol><li><p><strong>State parameters:</strong></p><ul><li>First <code>N</code> entries: state mean <code>mu</code>.</li><li>Next <code>N^2</code> entries: entries of <code>Phi</code> (stored columnwise).</li><li>Next <code>N(N+1)/2</code> entries: unconstrained parameters for D_state (used to form Omega).</li></ul></li><li><p><strong>Measurement parameters:</strong></p><ul><li>Next <code>M</code> entries: <code>A</code>.</li><li>Next <code>M×N</code> entries: entries of <code>B</code> (reshaped as an M×N matrix).</li><li>Next <code>M×N^2</code> entries: entries for <code>C</code>. (Interpreted as M matrices of size N×N.)</li><li>Next <code>M(M+1)/2</code> entries: unconstrained parameters for D_meas (used to form D).</li><li>Final <code>M×M</code> entries: entries of <code>α</code> (reshaped as an M×M matrix).</li></ul></li></ol><p><strong>Total expected length:</strong></p><pre><code class="nohighlight hljs">N + N^2 + N(N+1)/2  +  M + M×N + M×N^2 + M(M+1)/2 + M^2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/ed6acd68d0a251f2c0b0c2028b6c5e197a8a98ee/src/types/parameters.jl#L466-L510">source</a></section></article><h2 id="Plotting-API"><a class="docs-heading-anchor" href="#Plotting-API">Plotting API</a><a id="Plotting-API-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.kalman_filter_truth_plot" href="#QuadraticKalman.kalman_filter_truth_plot"><code>QuadraticKalman.kalman_filter_truth_plot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kalman_filter_truth_plot(X, results)</code></pre><p>Create a plot comparing true states with Kalman filter estimates.</p><p><strong>Arguments</strong></p><ul><li><code>X</code>: Matrix of true state values (N×T)</li><li><code>results</code>: FilterOutput object containing filtered state estimates</li></ul><p><strong>Returns</strong></p><p>A plot showing true states, filtered estimates, and confidence intervals</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/ed6acd68d0a251f2c0b0c2028b6c5e197a8a98ee/src/plotting/recipes.jl#L408-L419">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.kalman_smoother_truth_plot" href="#QuadraticKalman.kalman_smoother_truth_plot"><code>QuadraticKalman.kalman_smoother_truth_plot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kalman_smoother_truth_plot(X, results)</code></pre><p>Create a plot comparing true states with Kalman smoother estimates.</p><p><strong>Arguments</strong></p><ul><li><code>X</code>: Matrix of true state values (N×T)</li><li><code>results</code>: SmootherOutput object containing smoothed state estimates</li></ul><p><strong>Returns</strong></p><p>A plot showing true states, smoothed estimates, and confidence intervals</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/ed6acd68d0a251f2c0b0c2028b6c5e197a8a98ee/src/plotting/recipes.jl#L422-L434">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.kalman_filter_plot" href="#QuadraticKalman.kalman_filter_plot"><code>QuadraticKalman.kalman_filter_plot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kalman_filter_plot(results)</code></pre><p>Create a plot of Kalman filter estimates.</p><p><strong>Arguments</strong></p><ul><li><code>results</code>: FilterOutput object containing filtered state estimates</li></ul><p><strong>Returns</strong></p><p>A plot showing filtered estimates and confidence intervals</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/ed6acd68d0a251f2c0b0c2028b6c5e197a8a98ee/src/plotting/recipes.jl#L437-L447">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.kalman_smoother_plot" href="#QuadraticKalman.kalman_smoother_plot"><code>QuadraticKalman.kalman_smoother_plot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kalman_smoother_plot(results)</code></pre><p>Create a plot of Kalman smoother estimates.</p><p><strong>Arguments</strong></p><ul><li><code>results</code>: SmootherOutput object containing smoothed state estimates</li></ul><p><strong>Returns</strong></p><p>A plot showing smoothed estimates and confidence intervals</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/ed6acd68d0a251f2c0b0c2028b6c5e197a8a98ee/src/plotting/recipes.jl#L450-L460">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Saturday 1 February 2025 03:50">Saturday 1 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
