<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · QuadraticKalman.jl</title><meta name="title" content="API Reference · QuadraticKalman.jl"/><meta property="og:title" content="API Reference · QuadraticKalman.jl"/><meta property="twitter:title" content="API Reference · QuadraticKalman.jl"/><meta name="description" content="Documentation for QuadraticKalman.jl."/><meta property="og:description" content="Documentation for QuadraticKalman.jl."/><meta property="twitter:description" content="Documentation for QuadraticKalman.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">QuadraticKalman.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/dleather/QuadraticKalman.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/dleather/QuadraticKalman.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.QKData" href="#QuadraticKalman.QKData"><code>QuadraticKalman.QKData</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QKData{T&lt;:Real,N}</code></pre><p>A data structure for holding an N-dimensional array of real values (<code>Y</code>) plus two integer fields (<code>M</code>, <code>T̄</code>) derived from its dimensions. Typically, <code>M</code> and <code>T̄</code> might represent specific sizes used later in computations.</p><p><strong>Fields</strong></p><ul><li><code>Y::AbstractArray{T,N}</code> : The underlying data array (N-dimensional, element type <code>&lt;: Real</code>).</li><li><code>M::Int</code> : The first dimension of <code>Y</code> if <code>Y</code> is at least 2D. If <code>N == 1</code>, we define <code>M = 1</code>.</li><li><code>T_bar::Int</code> : One less than the “second dimension” in a 2D case, or <code>length(Y) - 1</code> for a 1D vector.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/6d98ed56ac02395ace8315abc0393ed280c96dd9/src/types/data.jl#L42-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.QKModel" href="#QuadraticKalman.QKModel"><code>QuadraticKalman.QKModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QKModel{T&lt;:Real, T2&lt;:Real}</code></pre><p>Main structure containing all parameters and moments needed for the quadratic Kalman filter.</p><p><strong>Fields</strong></p><ul><li><code>state::StateParams{T}</code>: Parameters for the state equation</li><li><code>meas::MeasParams{T}</code>: Parameters for the measurement equation  </li><li><code>aug_state::AugStateParams{T,T2}</code>: Parameters for the augmented state space</li><li><code>moments::Moments{T}</code>: Unconditional moments of the state and augmented state</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>T</code>: The main numeric type used for most parameters (e.g. Float64)</li><li><code>T2</code>: A possibly different numeric type used for Lambda in AugStateParams</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/6d98ed56ac02395ace8315abc0393ed280c96dd9/src/types/parameters.jl#L126-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.QKFOutput" href="#QuadraticKalman.QKFOutput"><code>QuadraticKalman.QKFOutput</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QKFOutput{T&lt;:Real}</code></pre><p>Combined container for both filter and smoother outputs.</p><p><strong>Fields</strong></p><ul><li><code>filter::FilterOutput{T}</code>: Results from the filter</li><li><code>smoother::SmootherOutput{T}</code>: Results from the smoother</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/6d98ed56ac02395ace8315abc0393ed280c96dd9/src/types/outputs.jl#L98-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.FilterOutput" href="#QuadraticKalman.FilterOutput"><code>QuadraticKalman.FilterOutput</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FilterOutput{T&lt;:Real}</code></pre><p>Container for outputs from the Quadratic Kalman Filter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/6d98ed56ac02395ace8315abc0393ed280c96dd9/src/types/outputs.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.SmootherOutput" href="#QuadraticKalman.SmootherOutput"><code>QuadraticKalman.SmootherOutput</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SmootherOutput{T&lt;:Real}</code></pre><p>Container for outputs from the Quadratic Kalman Smoother.</p><p><strong>Fields</strong></p><ul><li><code>Z_smooth::Matrix{T}</code>: Smoothed states (P × (T̄+1))</li><li><code>P_smooth::Array{T,3}</code>: Smoothed covariances (P × P × (T̄+1))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/6d98ed56ac02395ace8315abc0393ed280c96dd9/src/types/outputs.jl#L68-L76">source</a></section></article><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.qkf_filter" href="#QuadraticKalman.qkf_filter"><code>QuadraticKalman.qkf_filter</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qkf_filter(data::QKData{T1,1}, model::QKModel{T,T2})</code></pre><p>Run the <strong>Quadratic Kalman Filter (QKF)</strong> on a time series of length <code>T̄</code>,  returning a new set of result arrays (out-of-place).</p><p><strong>Description</strong></p><p>This function implements the same <em>quadratic</em> Kalman filter recursion  as <code>qkf_filter!</code>, but instead of updating arrays in-place, it allocates  new arrays for predictions, updates, and outputs. This can be simpler to  use in contexts where you don&#39;t want to mutate or reuse <code>data</code> and <code>model</code>,  but it may be less memory-efficient for large-scale problems.</p><p>At each time step, it performs:</p><ol><li><strong>State Prediction</strong> (<code>predict_Z_tt</code> / <code>predict_P_tt</code>)</li><li><strong>Measurement Prediction</strong> (<code>predict_Y_tt</code> / <code>predict_M_ttm1</code>)</li><li><strong>Kalman Gain Computation</strong> (<code>compute_K_t</code>)</li><li><strong>State &amp; Covariance Update</strong> (<code>update_Z_tt</code>, <code>update_P_tt</code>)</li><li><strong>PSD Correction</strong> (<code>correct_Zₜₜ</code>)</li><li><strong>Log-Likelihood</strong> computation.</li></ol><p><strong>Arguments</strong></p><ul><li><code>data::QKData{T1,1}</code>   Same structure as in <code>qkf_filter!</code>, with fields:<ul><li><code>Y::Vector{T1}</code>, <code>T̄::Int</code>, <code>M::Int</code>.</li></ul></li><li><code>model::QKModel{T,T2}</code>   Same parameter structure as in <code>qkf_filter!</code>, with fields:<ul><li><code>N::Int</code>, <code>P::Int</code>, <code>μ̃ᵘ, Σ̃ᵘ</code>, etc.</li></ul></li></ul><p><strong>Return</strong></p><p>A named tuple with fields:</p><ul><li><code>ll_t::Vector{Float64}</code>   Per-time-step log-likelihoods (size = <code>T̄</code>).</li><li><code>Z_tt::Array{T,3}</code>   The filtered state at each time step (dimensions <code>(T, P, T̄+1)</code> in your usage).</li><li><code>P_tt::Array{T,4}</code>   The filtered state covariance array.</li><li><code>Y_ttm1::Vector{T}</code>   Predicted measurement for each step.</li><li><code>M_ttm1::Array{T,4}</code>   Predicted measurement covariances.</li><li><code>K_t::Array{T,4}</code>   The Kalman gain for each time step.</li><li><code>Z_ttm1::Array{T,3}</code>   One-step-ahead predicted states.</li><li><code>P_ttm1::Array{T,4}</code>   One-step-ahead predicted covariances.</li></ul><p><strong>Details</strong></p><ol><li><strong>Initialization</strong>:<ul><li>Creates new arrays for <code>Z_tt</code> and <code>P_tt</code> and sets the initial state  to <code>aug_mean</code> and <code>aug_cov</code>.</li></ul></li><li><strong>Time Loop</strong>: <ul><li><strong>Prediction</strong>: <code>predict_Z_tt</code>, <code>predict_P_tt</code>.</li><li><strong>Measurement</strong>: <code>predict_Y_tt</code>, <code>predict_M_ttm1</code>.</li><li><strong>Gain &amp; Update</strong>: <code>compute_K_t</code>, <code>update_Z_tt</code>, <code>update_P_tt</code>.</li><li><strong>Correction</strong>: <code>correct_Z_tt</code> for PSD.</li><li><strong>Likelihood</strong>: <code>compute_loglik</code>.</li></ul></li><li><strong>No In-Place Mutation</strong>:<ul><li>Each step returns fresh arrays; original inputs are not modified.</li></ul></li></ol><p><strong>Example</strong></p><p>```julia data = QKData(Y, M=measurement<em>dim, T̄=length(Y)-1) model = QKModel(...) result = qkf</em>filter(data, model)</p><p>@show result.ll<em>t @show result.Z</em>tt[:, end]   # final state &#39;&#39;&#39;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/6d98ed56ac02395ace8315abc0393ed280c96dd9/src/core/filter.jl#L1051-L1128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.qkf_filter!" href="#QuadraticKalman.qkf_filter!"><code>QuadraticKalman.qkf_filter!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qkf_filter!(data::QKData{T1,1}, model::QKModel{T,T2})</code></pre><p>Run the <strong>Quadratic Kalman Filter (QKF)</strong> on a time series of length <code>T̄</code>, modifying the result in-place.</p><p><strong>Description</strong></p><p>This function implements a Kalman-like recursive filter where the state  vector <code>Zₜ</code> includes not only the usual mean component <code>xₜ</code> but also  terms for the second-moment <code>(x xᵀ)ₜ</code>, making it a <em>quadratic</em> extension.  At each time step, it performs:</p><ol><li><strong>State Prediction</strong> (<code>predict_Zₜₜ₋₁!</code> / <code>predict_Pₜₜ₋₁!</code>)</li><li><strong>Measurement Prediction</strong> (<code>predict_Yₜₜ₋₁!</code> / <code>predict_Mₜₜ₋₁!</code>)</li><li><strong>Kalman Gain Computation</strong> (<code>compute_Kₜ!</code>)</li><li><strong>State &amp; Covariance Update</strong> (<code>update_Zₜₜ!</code>, <code>update_Pₜₜ!</code>)</li><li><strong>PSD Correction</strong> (<code>correct_Zₜₜ!</code>)</li><li><strong>Log-Likelihood</strong> computation for the current innovation.</li></ol><p>Unlike the non-mutating version (<code>qkf_filter</code>), this function reuses  and mutates internal arrays and data structures in-place, which can  improve performance and reduce memory allocations.</p><p><strong>Arguments</strong></p><ul><li><p><code>data::QKData{T1,1}</code>   A structure holding:</p><ul><li><code>Y::Vector{T1}</code> of length <code>T̄+1</code>, containing observations.  Typically, <code>Y[1]</code> is an initial placeholder and <code>Y[2..end]</code>  are the actual measurements.</li><li><code>T_bar::Int</code> the total number of time steps (excluding index 0).</li><li><code>M::Int</code> the dimension of the measurement at each time step.</li></ul></li><li><p><code>model::QKModel{T,T2}</code>   A parameter structure holding:</p><ul><li><code>N::Int</code>: State dimension (for the mean part).</li><li><code>P::Int</code>: Dimension of the augmented &quot;quadratic&quot; state  (<code>P = N + N(N+1)/2</code>).</li><li><code>μ_aug, Σ_aug</code>: The unconditional mean and covariance used for  initialization.</li><li>Additional model matrices or functions (e.g., <code>Φ_aug</code>, <code>B_aug</code>, <code>A</code>, <code>V</code>)  accessed via subroutines.</li></ul></li></ul><p><strong>Return</strong></p><p>A named tuple with fields:</p><ul><li><code>ll_t::Vector{Float64}</code>   The per-time-step log-likelihoods (size = <code>T̄</code>).</li><li><code>Z_tt::Array{T,3}</code>   The filtered state at each time step. Dimensions: <code>(T, P, T̄+1)</code> in your  specific code (or <code>(P, T̄+1)</code> in a more generic version).</li><li><code>Pₜₜ::Array{T,4}</code>   The filtered state covariance array. Dimensions often <code>(T, P, P, T̄+1)</code>  in your code.</li><li><code>Yₜₜ₋₁::Vector{T}</code>   The predicted measurement at each time step (size = <code>T̄</code>).</li><li><code>M_ttm1::Array{T,4}</code>   The predicted measurement covariance, dimensions <code>(T, M, M, T̄)</code>.</li><li><code>K_t::Array{T,4}</code>   The Kalman gain for each time step, <code>(T, P, M, T̄)</code>.</li><li><code>Zₜₜ₋₁::Array{T,3}</code>   One-step-ahead predicted states.</li><li><code>Pₜₜ₋₁::Array{T,4}</code>   One-step-ahead predicted covariances.</li><li><code>Σ_ttm1::Array{T,4}</code>   Any intermediate covariance terms used for prediction.</li></ul><p><strong>Details</strong></p><ol><li><strong>Initialization</strong>: <ul><li><code>Zₜₜ[:, 1] .= μ̃ᵘ</code> and <code>Pₜₜ[:,:,1] .= Σ̃ᵘ</code>.</li></ul></li><li><strong>Recursive Steps</strong> (<code>for t in 1:T̄</code>):<ul><li><strong>Prediction</strong>: <code>predict_Zₜₜ₋₁!</code> / <code>predict_Pₜₜ₋₁!</code>.</li><li><strong>Measurement</strong>: <code>predict_Yₜₜ₋₁!</code> / <code>predict_Mₜₜ₋₁!</code>.</li><li><strong>Gain &amp; Update</strong>: <code>compute_Kₜ!</code>, then <code>update_Zₜₜ!</code> / <code>update_Pₜₜ!</code>.</li><li><strong>Correction</strong>: <code>correct_Z_tt!</code> clamps negative eigenvalues  for PSD.</li><li><strong>Likelihood</strong>: <code>compute_loglik!</code> appends the log-likelihood.</li></ul></li><li><strong>Positive Semidefinite Correction</strong>: <ul><li>Negative eigenvalues introduced by approximation are set to zero.</li></ul></li></ol><p><strong>Example</strong></p><pre><code class="language-julia hljs">data = QKData(Y, M=measurement_dim, T̄=length(Y)-1)
model = QKModel(...)
result = qkf_filter!(data, model)

@show result.ll_t
@show result.Z_tt[:, end]   # final state</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/6d98ed56ac02395ace8315abc0393ed280c96dd9/src/core/filter.jl#L894-L987">source</a></section><section><div><pre><code class="language-julia hljs">qkf_filter!(data::QKData{T1,1}, model::QKModel{T,T2})</code></pre><p>Run the <strong>Quadratic Kalman Filter (QKF)</strong> on a time series of length <code>T̄</code>.</p><p><strong>Description</strong></p><p>This function implements a Kalman-like recursive filter where the state  vector <code>Z_t</code> includes not only the usual mean component <code>xₜ</code> but also  terms for the second-moment <code>(x xᵀ)ₜ</code>, making it a <em>quadratic</em> extension.  At each time step, it performs:</p><ol><li><strong>State Prediction</strong> (<code>predict_Z_ttm1</code> / <code>predict_P_ttm1</code>)</li><li><strong>Measurement Prediction</strong> (<code>predict_Y_ttm1</code> / <code>predict_M_ttm1</code>)</li><li><strong>Kalman Gain Computation</strong> (<code>compute_K_t</code>)</li><li><strong>State &amp; Covariance Update</strong> (<code>update_Zₜₜ!</code>, <code>update_Pₜₜ!</code>)</li><li><strong>PSD Correction</strong>: Ensures the implied covariance is positive semidefinite  by clamping negative eigenvalues via <code>correct_Zₜₜ!</code>.</li><li><strong>Log-Likelihood</strong> computation for the current innovation.</li></ol><p>The filter stores and returns the entire history of filtered states, covariances, predicted measurements, and related arrays. </p><p><strong>Arguments</strong></p><ul><li><p><code>data::QKData{T1,1}</code>   A structure holding:</p><ul><li><code>Y::Vector{T1}</code> of length <code>T_bar+1</code>, which contains observations  (<code>Y[1]</code> is unused or some initial placeholder, and <code>Y[2..end]</code> are the actual measurements).</li><li><code>T_bar::Int</code> the total number of time steps (excluding index 0).</li><li><code>M::Int</code> the dimension of the measurement at each time step.</li></ul></li><li><p><code>model::QKModel{T,T2}</code>   A parameter structure holding:</p><ul><li><code>N::Int</code>: State dimension (for the mean part).</li><li><code>P::Int</code>: Dimension of the augmented &quot;quadratic&quot; state vector  (<code>P = N + N(N+1)/2</code>).</li><li><code>aug_mean, aug_cov</code>: The unconditional mean and covariance used for initialization.</li><li>Additional model matrices or functions (e.g., <code>Phi_aug</code>, <code>B_aug</code>, <code>A</code>, <code>V</code>),  typically accessed via separate predict/update subroutines.</li></ul></li></ul><p><strong>Return</strong></p><p>A named tuple with fields:</p><ul><li><p><code>ll_t::Vector{Float64}</code>   The per-time-step log-likelihoods of the innovations (size = <code>T_bar</code>).</p></li><li><p><code>Z_tt::Matrix{T}</code>   The updated (&quot;filtered&quot;) state at each time step. Dimensions: <code>(P, T_bar+1)</code>,  where column <code>k</code> corresponds to time index <code>k-1</code>.</p></li><li><p><code>P_tt::Array{T,3}</code>   The updated (&quot;filtered&quot;) state covariance array (or the augmented second-moment  representation) at each time step. Dimensions: <code>(P, P, T_bar+1)</code>.</p></li><li><p><code>Y_ttm1::Vector{T}</code>   The predicted measurement at each time step (size = <code>T_bar</code>).</p></li><li><p><code>M_ttm1::Array{T,3}</code>   The predicted measurement covariance at each time step (dimensions: <code>(M, M, T_bar)</code>).</p></li><li><p><code>K_t::Array{T,3}</code>   The Kalman gain at each time step <code>(P, M, T_bar)</code>.</p></li><li><p><code>Z_ttm1::Matrix{T}</code>   The one-step-ahead predicted state (dimensions: <code>(P, T_bar)</code>).</p></li><li><p><code>P_ttm1::Array{T,4}</code>   The one-step-ahead predicted covariance (dimensions: <code>(P, P, T_bar)</code>).</p></li><li><p><code>Σ_ttm1::Array{T,4}</code>   Any intermediate state-dependent covariance terms added during prediction  (dimensions: <code>(P, P, T_bar)</code>).</p></li></ul><p><strong>Details</strong></p><ol><li><p><strong>Initialization</strong>:  </p><ul><li><code>Z_tt[:,1] .= aug_mean</code> and <code>P_tt[:,:,1] .= aug_cov</code>, representing the state at time 0.</li></ul></li><li><p><strong>Time Loop</strong> (<code>for t in 1:T_bar</code>):  </p><ul><li><strong>Predict</strong> step: <ul><li><code>predict_Z_ttm1</code> sets <code>Z_ttm1[:,t]</code> from <code>Z_tt[:,t]</code>.</li><li><code>predict_P_ttm1</code> sets <code>P_ttm1[:,:,t]</code> from <code>P_tt[:,:,t]</code>.</li></ul></li><li><strong>Measurement</strong> step: <ul><li><code>predict_Y_ttm1</code> computes <code>Y_ttm1[t]</code> from <code>Z_ttm1[:,t]</code>.</li><li><code>predict_M_ttm1</code> updates <code>M_ttm1[:,:,t]</code>.</li></ul></li><li><strong>Gain &amp; Update</strong>:<ul><li><code>compute_K_t</code> obtains the Kalman gain <code>K_t[:,:,t]</code>.</li><li><code>update_Z_tt</code> and <code>update_P_tt</code> yield the next <code>Z_tt[:,t+1]</code> and <code>P_tt[:,:,t+1]</code>.</li></ul></li><li><strong>Correction</strong>:  <ul><li><code>correct_Z_tt</code> clamps negative eigenvalues in the implied covariance portion  of <code>Z_tt</code> to ensure PSD. </li></ul></li><li><strong>Likelihood</strong>:<ul><li><code>compute_loglik</code> appends/logs the innovation-based log-likelihood  in <code>ll_t[t]</code>.</li></ul></li></ul></li><li><p><strong>Positive Semidefinite Correction</strong>:</p><ul><li>Because the filter tracks <code>[X Xᵀ] - X Xᵀᵀ</code> as a covariance block, it can  become indefinite due to linearization or numerical issues. We enforce  PSD by zeroing out negative eigenvalues in <code>correct_Zₜₜ!</code>.</li><li>This step is not strictly differentiable at eigenvalues crossing zero.  If you need AD through the filter, consider an alternative correction  or a custom adjoint.</li></ul></li></ol><p><strong>Example</strong></p><p>```julia data = QKData(Y, M=measurement<em>dim, T</em>bar=length(Y)-1) model = QKModel( ... )   # set up your model</p><p>result = qkf_filter!(data, model)</p><p>@show result.ll<em>t @show result.Z</em>tt[:, end]   # final state vector</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/6d98ed56ac02395ace8315abc0393ed280c96dd9/src/core/filter.jl#L1181-L1296">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.qkf_smoother" href="#QuadraticKalman.qkf_smoother"><code>QuadraticKalman.qkf_smoother</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qkf_smoother( Z, P, Z_pred, P_pred, T_bar, H_aug, G_aug, Φ_aug, dof ) -&gt; (Z_smooth, P_smooth)</code></pre><p>Out-of-place version of the QKF smoother. Returns new arrays rather than overwriting the input ones.</p><p><strong>Description</strong></p><p>Identical to qkf<em>smoother! in logic, but it allocates new arrays Z</em>smooth and P_smooth for the smoothed results. This is often simpler for AD frameworks that do not allow in-place mutation of arrays.</p><p><strong>Returns</strong></p><ul><li><code>Z_smooth::Matrix{T}</code>: (P × (T̄+1)) smoothed states</li><li><code>P_smooth::Array{T,3}</code>: (P × P × (T̄+1)) smoothed covariances</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">Z_smooth, P_smooth = qkf_smoother(Z, P, Z_pred, P_pred, T̄, Hn, Gn, H̃, Φ̃, n)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/6d98ed56ac02395ace8315abc0393ed280c96dd9/src/core/smoother.jl#L114-L132">source</a></section><section><div><pre><code class="language-julia hljs">qkf_smoother(filter_output::FilterOutput{T}, params::QKParams{T,T2}) where {T&lt;:Real, T2&lt;:Real}</code></pre><p>Out-of-place backward smoothing for the QKF using filter outputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/6d98ed56ac02395ace8315abc0393ed280c96dd9/src/core/smoother.jl#L173-L177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.qkf_smoother!" href="#QuadraticKalman.qkf_smoother!"><code>QuadraticKalman.qkf_smoother!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qkf_smoother!(
    Z::AbstractMatrix{T},      # Filtered states   (P × (T_bar+1))
    P::AbstractArray{T, 3},    # Filtered covariances (P × P × (T_bar+1))
    Z_pred::AbstractMatrix{T}, # One-step-ahead predicted states (P × T_bar)
    P_pred::AbstractArray{T,3},
    T_bar::Int,
    Hn::Matrix{T},  Gn::Matrix{T},  H_aug::Matrix{T},  Φ_aug::Matrix{T},
    dof::Int
) where {T&lt;:Real}</code></pre><p>Perform <strong>in-place</strong> backward smoothing for the Quadratic Kalman Filter (QKF).</p><p><strong>Description</strong></p><p>Given the forward-filtered estimates <code>(Z, P)</code> from <code>t=1..T_bar</code>, plus the  one-step-ahead predictions <code>(Z_pred, P_pred)</code> and the special matrices  (H<em>aug, G</em>aug) that handle the dimension reduction via  Vech(·)/Vec(·), this function computes <code>Z[:,t]</code> and <code>P[:,:,t]</code> for  <code>t = T_bar-1 .. 1</code> in backward fashion to produce the smoothed estimates  (Zₜ|T<em>bar, PZₜ|T</em>bar).  </p><p><strong>Mathematical Form (Backward Pass)</strong></p><ol><li><p>Compute   Fₜ = (H̃ₙPᵗ|ᵗᶻH̃ₙ&#39;)(H̃ₙΦ̃G̃ₙ)&#39;(H̃ₙPᵗ⁺¹|ᵗᶻH̃ₙ&#39;)⁻¹ but implemented via solves (rather than explicit inverses) for numerical stability.</p></li><li><p>Then update (in H̃ₙ-transformed space): H̃ₙZₜ|ₜ = H̃ₙZₜ|ₜ + Fₜ(H̃ₙZₜ₊₁|ₜ - H̃ₙZₜ₊₁|ₜ)</p></li><li><p>And similarly for the covariance: (H̃ₙPᵗ|ᵀᶻH̃ₙ&#39;) = (H̃ₙPᵗ|ᵗᶻH̃ₙ&#39;) + Fₜ[(H̃ₙPᵗ⁺¹|ᵀᶻH̃ₙ&#39;) - (H̃ₙPᵗ⁺¹|ᵗᶻH̃ₙ&#39;)]Fₜ&#39;</p></li><li><p>Finally, transform back to get <code>Zₜ|T</code> and <code>Pᵗ|ᵀᶻ</code> in the full (Vec/augmented) space if necessary.</p></li></ol><p><strong>Arguments</strong></p><ul><li><code>Z::AbstractMatrix{T}</code>: On entry, <code>Z[:,t]</code> = <code>Zₜ|T</code> for each <code>t</code>. On exit, it will contain the smoothed states <code>Zₜ|T</code>.</li><li><code>P::AbstractArray{T,3}</code>: On entry, <code>P[:,:,t]</code> = <code>Pᵗ|ᵀᶻ</code>.  On exit, <code>P[:,:,t]</code> = <code>Pᵗ|ᵀᶻ</code>.</li><li><code>Z_pred::AbstractMatrix{T}</code>, <code>P_pred::AbstractArray{T,3}</code>:  The one-step-ahead predicted states/covariances from the forward pass, i.e. <code>Z_pred[:,t] = Zₜ|ₜ</code>, <code>P_pred[:,:,t] = P^Zₜ|ₜ</code>.</li><li><code>T_bar::Int</code>: Total time steps (excluding time 0).</li><li><code>Hn::Matrix{T}</code>, <code>Gn::Matrix{T}</code>: The selection/duplication operators  for Vec/Vech transforms of block <code>(x xᵀ)</code>. Usually size <code>(n(n+1) × n(n+3)/2)</code> or similarly.</li><li><code>H_aug::Matrix{T}</code>, <code>Φ_aug::Matrix{T}</code>: The augmented versions  (H<em>aug, G</em>aug) used in the QKF recursion.</li><li><code>dof::Int</code>: Dimension parameter (often <code>n</code> or <code>P</code>). Adjust to your model.</li></ul><p><strong>Notes</strong></p><ul><li>This function runs backward from <code>t = T_bar-1</code> down to <code>t = 1</code>, using  the final values <code>(Z[:, T_bar], P[:,:, T_bar])</code> as the terminal condition  (<code>Z_{T_bar|T_bar}, P^Z_{T_bar|T_bar}</code>).</li><li>If your AD library supports destructive updates, this approach should  be AD-friendly; if not, consider the out-of-place version <code>qkf_smoother</code>.</li></ul><p><strong>Example</strong></p><p>Suppose you already ran the forward filter, so you have:     Z, P, Z<em>pred, P</em>pred, plus your special matrices.</p><pre><code class="nohighlight hljs">qkf_smoother!(Z, P, Z_pred, P_pred, T_bar, Hn, Gn, H_aug, Φ_aug, n)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/6d98ed56ac02395ace8315abc0393ed280c96dd9/src/core/smoother.jl#L2-L69">source</a></section><section><div><pre><code class="language-julia hljs">qkf_smoother!(filter_output::FilterOutput{T}, model::QKModel{T,T2}) where {T&lt;:Real, T2&lt;:Real}</code></pre><p>In-place backward smoothing for the QKF using filter outputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/6d98ed56ac02395ace8315abc0393ed280c96dd9/src/core/smoother.jl#L152-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.qkf" href="#QuadraticKalman.qkf"><code>QuadraticKalman.qkf</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qkf(data::QKData{T1,N}, params::QKParams{T,T2}) where {T1,T,T2,N}</code></pre><p>Run both QKF filter and smoother, returning combined results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/6d98ed56ac02395ace8315abc0393ed280c96dd9/src/core/smoother.jl#L198-L202">source</a></section><section><div><pre><code class="language-julia hljs">qkf(data::QKData{T1,N}, model::QKModel{T,T2}) where {T1&lt;:Real, T&lt;:Real, T2&lt;:Real, N}</code></pre><p>Reversed argument order for backwards compatibility.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/6d98ed56ac02395ace8315abc0393ed280c96dd9/src/core/smoother.jl#L215-L219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuadraticKalman.get_measurement" href="#QuadraticKalman.get_measurement"><code>QuadraticKalman.get_measurement</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_measurement(data::QKData{T,N}, t::Int) where {T&lt;:Real, N}</code></pre><p>Extract measurement at time t from QKData.  For vector data returns a scalar, for matrix data returns a vector.</p><p><strong>Arguments</strong></p><ul><li><code>data::QKData{T,N}</code>: Data structure</li><li><code>t::Int</code>: Time index (1-based)</li></ul><p><strong>Returns</strong></p><ul><li>For N=1: Single measurement Y[t]</li><li>For N=2: Vector of measurements Y[:,t]</li></ul><p><strong>Throws</strong></p><ul><li>ArgumentError if t is out of bounds</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dleather/QuadraticKalman.jl/blob/6d98ed56ac02395ace8315abc0393ed280c96dd9/src/types/data.jl#L147-L163">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Thursday 30 January 2025 20:08">Thursday 30 January 2025</span>. Using Julia version 1.10.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
