var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QKData\nQKModel\nQKFOutput\nFilterOutput\nSmootherOutput","category":"page"},{"location":"api/#QuadraticKalman.QKData","page":"API Reference","title":"QuadraticKalman.QKData","text":"QKData{T<:Real,N}\n\nA data structure for holding an N-dimensional array of real values (Y) plus two integer fields (M, T̄) derived from its dimensions. Typically, M and T̄ might represent specific sizes used later in computations.\n\nFields\n\nY::AbstractArray{T,N} : The underlying data array (N-dimensional, element type <: Real).\nM::Int : The first dimension of Y if Y is at least 2D. If N == 1, we define M = 1.\nT_bar::Int : One less than the “second dimension” in a 2D case, or length(Y) - 1 for a 1D vector.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuadraticKalman.QKModel","page":"API Reference","title":"QuadraticKalman.QKModel","text":"QKModel{T<:Real, T2<:Real}\n\nMain structure containing all parameters and moments needed for the quadratic Kalman filter.\n\nFields\n\nstate::StateParams{T}: Parameters for the state equation\nmeas::MeasParams{T}: Parameters for the measurement equation  \naug_state::AugStateParams{T,T2}: Parameters for the augmented state space\nmoments::Moments{T}: Unconditional moments of the state and augmented state\n\nType Parameters\n\nT: The main numeric type used for most parameters (e.g. Float64)\nT2: A possibly different numeric type used for Lambda in AugStateParams\n\n\n\n\n\n","category":"type"},{"location":"api/#QuadraticKalman.QKFOutput","page":"API Reference","title":"QuadraticKalman.QKFOutput","text":"QKFOutput{T<:Real}\n\nCombined container for both filter and smoother outputs.\n\nFields\n\nfilter::FilterOutput{T}: Results from the filter\nsmoother::SmootherOutput{T}: Results from the smoother\n\n\n\n\n\n","category":"type"},{"location":"api/#QuadraticKalman.FilterOutput","page":"API Reference","title":"QuadraticKalman.FilterOutput","text":"FilterOutput{T<:Real}\n\nContainer for outputs from the Quadratic Kalman Filter.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuadraticKalman.SmootherOutput","page":"API Reference","title":"QuadraticKalman.SmootherOutput","text":"SmootherOutput{T<:Real}\n\nContainer for outputs from the Quadratic Kalman Smoother.\n\nFields\n\nZ_smooth::Matrix{T}: Smoothed states (P × (T̄+1))\nP_smooth::Array{T,3}: Smoothed covariances (P × P × (T̄+1))\n\n\n\n\n\n","category":"type"},{"location":"api/#Functions","page":"API Reference","title":"Functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"qkf_filter\nqkf_filter!\nqkf_smoother\nqkf_smoother!\nqkf\nget_measurement","category":"page"},{"location":"api/#QuadraticKalman.qkf_filter","page":"API Reference","title":"QuadraticKalman.qkf_filter","text":"qkf_filter(data::QKData{T1,1}, model::QKModel{T,T2})\n\nRun the Quadratic Kalman Filter (QKF) on a time series of length T̄,  returning a new set of result arrays (out-of-place).\n\nDescription\n\nThis function implements the same quadratic Kalman filter recursion  as qkf_filter!, but instead of updating arrays in-place, it allocates  new arrays for predictions, updates, and outputs. This can be simpler to  use in contexts where you don't want to mutate or reuse data and model,  but it may be less memory-efficient for large-scale problems.\n\nAt each time step, it performs:\n\nState Prediction (predict_Z_tt / predict_P_tt)\nMeasurement Prediction (predict_Y_tt / predict_M_ttm1)\nKalman Gain Computation (compute_K_t)\nState & Covariance Update (update_Z_tt, update_P_tt)\nPSD Correction (correct_Zₜₜ)\nLog-Likelihood computation.\n\nArguments\n\ndata::QKData{T1,1}   Same structure as in qkf_filter!, with fields:\nY::Vector{T1}, T̄::Int, M::Int.\nmodel::QKModel{T,T2}   Same parameter structure as in qkf_filter!, with fields:\nN::Int, P::Int, μ̃ᵘ, Σ̃ᵘ, etc.\n\nReturn\n\nA named tuple with fields:\n\nll_t::Vector{Float64}   Per-time-step log-likelihoods (size = T̄).\nZ_tt::Array{T,3}   The filtered state at each time step (dimensions (T, P, T̄+1) in your usage).\nP_tt::Array{T,4}   The filtered state covariance array.\nY_ttm1::Vector{T}   Predicted measurement for each step.\nM_ttm1::Array{T,4}   Predicted measurement covariances.\nK_t::Array{T,4}   The Kalman gain for each time step.\nZ_ttm1::Array{T,3}   One-step-ahead predicted states.\nP_ttm1::Array{T,4}   One-step-ahead predicted covariances.\n\nDetails\n\nInitialization:\nCreates new arrays for Z_tt and P_tt and sets the initial state  to aug_mean and aug_cov.\nTime Loop: \nPrediction: predict_Z_tt, predict_P_tt.\nMeasurement: predict_Y_tt, predict_M_ttm1.\nGain & Update: compute_K_t, update_Z_tt, update_P_tt.\nCorrection: correct_Z_tt for PSD.\nLikelihood: compute_loglik.\nNo In-Place Mutation:\nEach step returns fresh arrays; original inputs are not modified.\n\nExample\n\n```julia data = QKData(Y, M=measurementdim, T̄=length(Y)-1) model = QKModel(...) result = qkffilter(data, model)\n\n@show result.llt @show result.Ztt[:, end]   # final state '''\n\n\n\n\n\n","category":"function"},{"location":"api/#QuadraticKalman.qkf_filter!","page":"API Reference","title":"QuadraticKalman.qkf_filter!","text":"qkf_filter!(data::QKData{T1,1}, model::QKModel{T,T2})\n\nRun the Quadratic Kalman Filter (QKF) on a time series of length T̄, modifying the result in-place.\n\nDescription\n\nThis function implements a Kalman-like recursive filter where the state  vector Zₜ includes not only the usual mean component xₜ but also  terms for the second-moment (x xᵀ)ₜ, making it a quadratic extension.  At each time step, it performs:\n\nState Prediction (predict_Zₜₜ₋₁! / predict_Pₜₜ₋₁!)\nMeasurement Prediction (predict_Yₜₜ₋₁! / predict_Mₜₜ₋₁!)\nKalman Gain Computation (compute_Kₜ!)\nState & Covariance Update (update_Zₜₜ!, update_Pₜₜ!)\nPSD Correction (correct_Zₜₜ!)\nLog-Likelihood computation for the current innovation.\n\nUnlike the non-mutating version (qkf_filter), this function reuses  and mutates internal arrays and data structures in-place, which can  improve performance and reduce memory allocations.\n\nArguments\n\ndata::QKData{T1,1}   A structure holding:\nY::Vector{T1} of length T̄+1, containing observations.  Typically, Y[1] is an initial placeholder and Y[2..end]  are the actual measurements.\nT_bar::Int the total number of time steps (excluding index 0).\nM::Int the dimension of the measurement at each time step.\nmodel::QKModel{T,T2}   A parameter structure holding:\nN::Int: State dimension (for the mean part).\nP::Int: Dimension of the augmented \"quadratic\" state  (P = N + N(N+1)/2).\nμ_aug, Σ_aug: The unconditional mean and covariance used for  initialization.\nAdditional model matrices or functions (e.g., Φ_aug, B_aug, A, V)  accessed via subroutines.\n\nReturn\n\nA named tuple with fields:\n\nll_t::Vector{Float64}   The per-time-step log-likelihoods (size = T̄).\nZ_tt::Array{T,3}   The filtered state at each time step. Dimensions: (T, P, T̄+1) in your  specific code (or (P, T̄+1) in a more generic version).\nPₜₜ::Array{T,4}   The filtered state covariance array. Dimensions often (T, P, P, T̄+1)  in your code.\nYₜₜ₋₁::Vector{T}   The predicted measurement at each time step (size = T̄).\nM_ttm1::Array{T,4}   The predicted measurement covariance, dimensions (T, M, M, T̄).\nK_t::Array{T,4}   The Kalman gain for each time step, (T, P, M, T̄).\nZₜₜ₋₁::Array{T,3}   One-step-ahead predicted states.\nPₜₜ₋₁::Array{T,4}   One-step-ahead predicted covariances.\nΣ_ttm1::Array{T,4}   Any intermediate covariance terms used for prediction.\n\nDetails\n\nInitialization: \nZₜₜ[:, 1] .= μ̃ᵘ and Pₜₜ[:,:,1] .= Σ̃ᵘ.\nRecursive Steps (for t in 1:T̄):\nPrediction: predict_Zₜₜ₋₁! / predict_Pₜₜ₋₁!.\nMeasurement: predict_Yₜₜ₋₁! / predict_Mₜₜ₋₁!.\nGain & Update: compute_Kₜ!, then update_Zₜₜ! / update_Pₜₜ!.\nCorrection: correct_Z_tt! clamps negative eigenvalues  for PSD.\nLikelihood: compute_loglik! appends the log-likelihood.\nPositive Semidefinite Correction: \nNegative eigenvalues introduced by approximation are set to zero.\n\nExample\n\ndata = QKData(Y, M=measurement_dim, T̄=length(Y)-1)\nmodel = QKModel(...)\nresult = qkf_filter!(data, model)\n\n@show result.ll_t\n@show result.Z_tt[:, end]   # final state\n\n\n\n\n\nqkf_filter!(data::QKData{T1,1}, model::QKModel{T,T2})\n\nRun the Quadratic Kalman Filter (QKF) on a time series of length T̄.\n\nDescription\n\nThis function implements a Kalman-like recursive filter where the state  vector Z_t includes not only the usual mean component xₜ but also  terms for the second-moment (x xᵀ)ₜ, making it a quadratic extension.  At each time step, it performs:\n\nState Prediction (predict_Z_ttm1 / predict_P_ttm1)\nMeasurement Prediction (predict_Y_ttm1 / predict_M_ttm1)\nKalman Gain Computation (compute_K_t)\nState & Covariance Update (update_Zₜₜ!, update_Pₜₜ!)\nPSD Correction: Ensures the implied covariance is positive semidefinite  by clamping negative eigenvalues via correct_Zₜₜ!.\nLog-Likelihood computation for the current innovation.\n\nThe filter stores and returns the entire history of filtered states, covariances, predicted measurements, and related arrays. \n\nArguments\n\ndata::QKData{T1,1}   A structure holding:\nY::Vector{T1} of length T_bar+1, which contains observations  (Y[1] is unused or some initial placeholder, and Y[2..end] are the actual measurements).\nT_bar::Int the total number of time steps (excluding index 0).\nM::Int the dimension of the measurement at each time step.\nmodel::QKModel{T,T2}   A parameter structure holding:\nN::Int: State dimension (for the mean part).\nP::Int: Dimension of the augmented \"quadratic\" state vector  (P = N + N(N+1)/2).\naug_mean, aug_cov: The unconditional mean and covariance used for initialization.\nAdditional model matrices or functions (e.g., Phi_aug, B_aug, A, V),  typically accessed via separate predict/update subroutines.\n\nReturn\n\nA named tuple with fields:\n\nll_t::Vector{Float64}   The per-time-step log-likelihoods of the innovations (size = T_bar).\nZ_tt::Matrix{T}   The updated (\"filtered\") state at each time step. Dimensions: (P, T_bar+1),  where column k corresponds to time index k-1.\nP_tt::Array{T,3}   The updated (\"filtered\") state covariance array (or the augmented second-moment  representation) at each time step. Dimensions: (P, P, T_bar+1).\nY_ttm1::Vector{T}   The predicted measurement at each time step (size = T_bar).\nM_ttm1::Array{T,3}   The predicted measurement covariance at each time step (dimensions: (M, M, T_bar)).\nK_t::Array{T,3}   The Kalman gain at each time step (P, M, T_bar).\nZ_ttm1::Matrix{T}   The one-step-ahead predicted state (dimensions: (P, T_bar)).\nP_ttm1::Array{T,4}   The one-step-ahead predicted covariance (dimensions: (P, P, T_bar)).\nΣ_ttm1::Array{T,4}   Any intermediate state-dependent covariance terms added during prediction  (dimensions: (P, P, T_bar)).\n\nDetails\n\nInitialization:  \nZ_tt[:,1] .= aug_mean and P_tt[:,:,1] .= aug_cov, representing the state at time 0.\nTime Loop (for t in 1:T_bar):  \nPredict step: \npredict_Z_ttm1 sets Z_ttm1[:,t] from Z_tt[:,t].\npredict_P_ttm1 sets P_ttm1[:,:,t] from P_tt[:,:,t].\nMeasurement step: \npredict_Y_ttm1 computes Y_ttm1[t] from Z_ttm1[:,t].\npredict_M_ttm1 updates M_ttm1[:,:,t].\nGain & Update:\ncompute_K_t obtains the Kalman gain K_t[:,:,t].\nupdate_Z_tt and update_P_tt yield the next Z_tt[:,t+1] and P_tt[:,:,t+1].\nCorrection:  \ncorrect_Z_tt clamps negative eigenvalues in the implied covariance portion  of Z_tt to ensure PSD. \nLikelihood:\ncompute_loglik appends/logs the innovation-based log-likelihood  in ll_t[t].\nPositive Semidefinite Correction:\nBecause the filter tracks [X Xᵀ] - X Xᵀᵀ as a covariance block, it can  become indefinite due to linearization or numerical issues. We enforce  PSD by zeroing out negative eigenvalues in correct_Zₜₜ!.\nThis step is not strictly differentiable at eigenvalues crossing zero.  If you need AD through the filter, consider an alternative correction  or a custom adjoint.\n\nExample\n\n```julia data = QKData(Y, M=measurementdim, Tbar=length(Y)-1) model = QKModel( ... )   # set up your model\n\nresult = qkf_filter!(data, model)\n\n@show result.llt @show result.Ztt[:, end]   # final state vector\n\n\n\n\n\n","category":"function"},{"location":"api/#QuadraticKalman.qkf_smoother","page":"API Reference","title":"QuadraticKalman.qkf_smoother","text":"qkf_smoother( Z, P, Z_pred, P_pred, T_bar, H_aug, G_aug, Φ_aug, dof ) -> (Z_smooth, P_smooth)\n\nOut-of-place version of the QKF smoother. Returns new arrays rather than overwriting the input ones.\n\nDescription\n\nIdentical to qkfsmoother! in logic, but it allocates new arrays Zsmooth and P_smooth for the smoothed results. This is often simpler for AD frameworks that do not allow in-place mutation of arrays.\n\nReturns\n\nZ_smooth::Matrix{T}: (P × (T̄+1)) smoothed states\nP_smooth::Array{T,3}: (P × P × (T̄+1)) smoothed covariances\n\nExample\n\nZ_smooth, P_smooth = qkf_smoother(Z, P, Z_pred, P_pred, T̄, Hn, Gn, H̃, Φ̃, n)\n\n\n\n\n\nqkf_smoother(filter_output::FilterOutput{T}, params::QKParams{T,T2}) where {T<:Real, T2<:Real}\n\nOut-of-place backward smoothing for the QKF using filter outputs.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuadraticKalman.qkf_smoother!","page":"API Reference","title":"QuadraticKalman.qkf_smoother!","text":"qkf_smoother!(\n    Z::AbstractMatrix{T},      # Filtered states   (P × (T_bar+1))\n    P::AbstractArray{T, 3},    # Filtered covariances (P × P × (T_bar+1))\n    Z_pred::AbstractMatrix{T}, # One-step-ahead predicted states (P × T_bar)\n    P_pred::AbstractArray{T,3},\n    T_bar::Int,\n    Hn::Matrix{T},  Gn::Matrix{T},  H_aug::Matrix{T},  Φ_aug::Matrix{T},\n    dof::Int\n) where {T<:Real}\n\nPerform in-place backward smoothing for the Quadratic Kalman Filter (QKF).\n\nDescription\n\nGiven the forward-filtered estimates (Z, P) from t=1..T_bar, plus the  one-step-ahead predictions (Z_pred, P_pred) and the special matrices  (Haug, Gaug) that handle the dimension reduction via  Vech(·)/Vec(·), this function computes Z[:,t] and P[:,:,t] for  t = T_bar-1 .. 1 in backward fashion to produce the smoothed estimates  (Zₜ|Tbar, PZₜ|Tbar).  \n\nMathematical Form (Backward Pass)\n\nCompute   Fₜ = (H̃ₙPᵗ|ᵗᶻH̃ₙ')(H̃ₙΦ̃G̃ₙ)'(H̃ₙPᵗ⁺¹|ᵗᶻH̃ₙ')⁻¹ but implemented via solves (rather than explicit inverses) for numerical stability.\nThen update (in H̃ₙ-transformed space): H̃ₙZₜ|ₜ = H̃ₙZₜ|ₜ + Fₜ(H̃ₙZₜ₊₁|ₜ - H̃ₙZₜ₊₁|ₜ)\nAnd similarly for the covariance: (H̃ₙPᵗ|ᵀᶻH̃ₙ') = (H̃ₙPᵗ|ᵗᶻH̃ₙ') + Fₜ[(H̃ₙPᵗ⁺¹|ᵀᶻH̃ₙ') - (H̃ₙPᵗ⁺¹|ᵗᶻH̃ₙ')]Fₜ'\nFinally, transform back to get Zₜ|T and Pᵗ|ᵀᶻ in the full (Vec/augmented) space if necessary.\n\nArguments\n\nZ::AbstractMatrix{T}: On entry, Z[:,t] = Zₜ|T for each t. On exit, it will contain the smoothed states Zₜ|T.\nP::AbstractArray{T,3}: On entry, P[:,:,t] = Pᵗ|ᵀᶻ.  On exit, P[:,:,t] = Pᵗ|ᵀᶻ.\nZ_pred::AbstractMatrix{T}, P_pred::AbstractArray{T,3}:  The one-step-ahead predicted states/covariances from the forward pass, i.e. Z_pred[:,t] = Zₜ|ₜ, P_pred[:,:,t] = P^Zₜ|ₜ.\nT_bar::Int: Total time steps (excluding time 0).\nHn::Matrix{T}, Gn::Matrix{T}: The selection/duplication operators  for Vec/Vech transforms of block (x xᵀ). Usually size (n(n+1) × n(n+3)/2) or similarly.\nH_aug::Matrix{T}, Φ_aug::Matrix{T}: The augmented versions  (Haug, Gaug) used in the QKF recursion.\ndof::Int: Dimension parameter (often n or P). Adjust to your model.\n\nNotes\n\nThis function runs backward from t = T_bar-1 down to t = 1, using  the final values (Z[:, T_bar], P[:,:, T_bar]) as the terminal condition  (Z_{T_bar|T_bar}, P^Z_{T_bar|T_bar}).\nIf your AD library supports destructive updates, this approach should  be AD-friendly; if not, consider the out-of-place version qkf_smoother.\n\nExample\n\nSuppose you already ran the forward filter, so you have:     Z, P, Zpred, Ppred, plus your special matrices.\n\nqkf_smoother!(Z, P, Z_pred, P_pred, T_bar, Hn, Gn, H_aug, Φ_aug, n)\n\n\n\n\n\nqkf_smoother!(filter_output::FilterOutput{T}, model::QKModel{T,T2}) where {T<:Real, T2<:Real}\n\nIn-place backward smoothing for the QKF using filter outputs.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuadraticKalman.qkf","page":"API Reference","title":"QuadraticKalman.qkf","text":"qkf(data::QKData{T1,N}, params::QKParams{T,T2}) where {T1,T,T2,N}\n\nRun both QKF filter and smoother, returning combined results.\n\n\n\n\n\nqkf(data::QKData{T1,N}, model::QKModel{T,T2}) where {T1<:Real, T<:Real, T2<:Real, N}\n\nReversed argument order for backwards compatibility.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuadraticKalman.get_measurement","page":"API Reference","title":"QuadraticKalman.get_measurement","text":"get_measurement(data::QKData{T,N}, t::Int) where {T<:Real, N}\n\nExtract measurement at time t from QKData.  For vector data returns a scalar, for matrix data returns a vector.\n\nArguments\n\ndata::QKData{T,N}: Data structure\nt::Int: Time index (1-based)\n\nReturns\n\nFor N=1: Single measurement Y[t]\nFor N=2: Vector of measurements Y[:,t]\n\nThrows\n\nArgumentError if t is out of bounds\n\n\n\n\n\n","category":"function"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Examples coming soon.","category":"page"},{"location":"#QuadraticKalman.jl","page":"Home","title":"QuadraticKalman.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package implementing the quadratic Kalman filter and smoother.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"QuadraticKalman\")","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QuadraticKalman.jl provides tools for state-space estimation with quadratic measurement equations. The package implements:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Quadratic Kalman Filter\nQuadratic Kalman Smoother\nSupport for missing observations\nEfficient matrix operations","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using QuadraticKalman\n\n# Create model\nmodel = QKModel(...)\n\n# Create data object\ndata = QKData(measurements)\n\n# Run filter\nresults = qkf(data, model)","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MIT License Copyright (c) 2024 David Leather Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"}]
}
