var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api/#Main-Types","page":"API Reference","title":"Main Types","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"QKData\nQKModel\nStateParams\nMeasParams\nMoments\nAugStateParams\nQKFOutput\nFilterOutput\nSmootherOutput","category":"page"},{"location":"api/#QuadraticKalman.QKData","page":"API Reference","title":"QuadraticKalman.QKData","text":"QKData{T<:Real,N}\n\nA data structure for holding an M x T_bar array of real values (Y) plus two integer fields (M, T_bar) derived from its dimensions. M is  the dimension of the measurement vector, 'Yt', and `Tbar` is the  number of time periods minus 1 (due to the autoregressive structure of the model).\n\nFields\n\nY::AbstractArray{T, N} : The underlying data array (N-dimensional, element type <: Real).\nM::Int : The first dimension of Y if Y is at least 2D. If N == 1, we define M = 1.\nT_bar::Int : One less than the “second dimension” in a 2D case, or length(Y) - 1 for a 1D vector.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuadraticKalman.QKModel","page":"API Reference","title":"QuadraticKalman.QKModel","text":"QKModel{T<:Real, T2<:Real}\n\nMain structure containing all parameters and moments needed for the quadratic Kalman filter.\n\nThis composite model encapsulates every component necessary to specify a quadratic state-space model. It bundles together the standard state evolution parameters, measurement parameters with quadratic terms, augmented state parameters for richer dynamics, and the unconditional moments that summarize the state behavior over time. This design enables integrated filtering and smoothing procedures within a unified framework.\n\nFields\n\nstate::StateParams{T}: Parameters governing the state process, defined by the equation Xt = μ + Φ X{t-1} + Ω εt, where μ is the initial state mean, Φ is the state transition matrix, and Ω scales the process noise εt.\nmeas::MeasParams{T}: Parameters for the measurement model, given by Yt = A + B Xt + α Y{t-1} + ∑{i=1}^M (Xt' Ci Xt) + D εt, including the intercept A, linear loading B, autoregressive term α, quadratic terms involving matrices C_i, and the measurement noise scaling D.\naug_state::AugStateParams{T,T2}: Parameters for the augmented state space which extend the state representation. This component includes transformed state means, transitions, and additional matrices that capture nonlinear or auxiliary features of the state process. The use of a secondary numeric type T2 facilitates compatibility with automatic differentiation.\nmoments::Moments{T}: The unconditional (or stationary) moments of both the state and the augmented state. This includes the long-run mean and covariance for the state dynamics as well as the augmented state, which are critical for initialization and diagnostic evaluation of the model.\n\nType Parameters\n\nT: The primary numeric type used for most parameters (e.g., Float64). It must be a subtype of Real, ensuring both numerical precision and compatibility with standard arithmetic operations.\nT2: A potentially different numeric type used specifically for parameters like Lambda in AugStateParams, often employed to leverage automatic differentiation (AD) techniques.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuadraticKalman.StateParams","page":"API Reference","title":"QuadraticKalman.StateParams","text":"StateParams{T<:Real}\n\nA structure representing the parameters that govern the evolution of the state in a state-space model. This type encapsulates the fundamental components required to describe the behavior of the state process, including its initial mean, transition dynamics, noise characteristics, and the resulting covariance.\n\nFields\n\nN::Int   The dimensionality of the state vector. This parameter specifies the number of state variables.\nmu::AbstractVector{T}   The initial state mean vector. It must have a length equal to N.\nPhi::AbstractMatrix{T}   The state transition matrix, which models how the state evolves over time. This matrix should be of size N×N.\nOmega::AbstractMatrix{T}   The state noise matrix, used to scale the impact of the stochastic noise on the state evolution. It must be of size N×N.\nSigma::AbstractMatrix{T}   The state covariance matrix, typically computed as Omega * Omega'. This matrix quantifies the uncertainty in the state.\n\nDetails\n\nThe state evolution of a typical state-space model is represented by the equation:     Xₜ = mu + Phi * Xₜ₋₁ + Omega * εₜ, where εₜ represents a white noise process. This structure is a critical component in facilitating both the filtering and smoothing processes within the QuadraticKalman framework, ensuring that the model's dynamics are accurately captured and that its stability conditions can be properly validated.\n\nThis structure is also designed to integrate smoothly with automatic differentiation tools, taking advantage of Julia's type system to provide both precision and performance in numerical computations.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuadraticKalman.MeasParams","page":"API Reference","title":"QuadraticKalman.MeasParams","text":"MeasParams{T<:Real}\n\nA container for the measurement equation parameters in a quadratic state-space model.\n\nThis structure holds all measurement-related parameters essential for specifying the measurement equation:\n\nYₜ = A + B * Xₜ + α * Yₜ₋₁ + ∑₍ᵢ₌₁₎ᴹ (Xₜ' * Cᵢ * Xₜ) + noise\n\nwhere:   • M: The number of measurement variables.   • A: A vector of intercept terms (length M).   • B: An M×N matrix mapping the state vector (of dimension N) to the measurement space.   • C: A vector of M matrices, each of size N×N, representing quadratic measurement parameters.   • D: An M×M matrix scaling the measurement noise.   • α: An M×M matrix capturing the autoregressive component in the measurement equation.   • V: An auxiliary M×M matrix computed as V = D * D', representing the covariance structure of the measurement noise.\n\nAll fields should be provided as concrete matrices or vectors (or will be derived from UniformScaling objects as needed), ensuring consistency and compatibility with downstream filtering and smoothing routines. The use of the @with_kw macro facilitates clear initialization and automatic field assignment.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuadraticKalman.Moments","page":"API Reference","title":"QuadraticKalman.Moments","text":"Moments{T<:Real}\n\nUnconditional Moments Structure for the Quadratic Kalman Filter.\n\nThis structure encapsulates the long-run (stationary) moments of both the state and the augmented state. These moments include the mean and covariance estimates, which are critical for initializing the filter and for conducting diagnostic evaluations of the model dynamics.\n\nFields:\n\nstate_mean::AbstractVector{T}: Unconditional (stationary) mean vector of the state.\nstate_cov::AbstractMatrix{T}: Unconditional covariance matrix of the state.\naug_mean::AbstractVector{T}: Unconditional mean vector of the augmented state.\naug_cov::AbstractMatrix{T}: Unconditional covariance matrix of the augmented state.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuadraticKalman.AugStateParams","page":"API Reference","title":"QuadraticKalman.AugStateParams","text":"AugStateParams{T<:Real, T2<:Real}\n\nAn augmented state parameter container designed for quadratic measurement models. This type extends the conventional state-space representation to incorporate quadratic measurement features, enabling advanced filtering and smoothing algorithms to effectively handle non-linear measurement equations.\n\nFields:\n\nmu_aug::AbstractVector{T}:   The augmented state mean vector, which integrates the original state mean with additional terms arising from quadratic components.\nPhi_aug::AbstractMatrix{T}:   The augmented state transition matrix. It extends the traditional state transition dynamics to include quadratic interactions.\nB_aug::AbstractMatrix{T}:   The augmented measurement matrix that relates the extended state vector to the observed measurements, accounting for both linear and quadratic effects.\nH_aug::AbstractMatrix{T}:   The augmented selection matrix used in mapping the original state space to the augmented space, facilitating the extraction of relevant subcomponents.\nG_aug::AbstractMatrix{T}:   The augmented duplication matrix, which assists in preserving the symmetry properties of quadratic forms when processing covariance or moment adjustments.\nLambda::AbstractMatrix{T2}:   A core structural matrix that captures the key quadratic interactions within the model. Its specific formulation supports the reconstruction of quadratic measures.\nL1::AbstractMatrix{T}:   An auxiliary matrix used for computing first-order moment corrections in the augmented state representation.\nL2::AbstractMatrix{T}:   An auxiliary matrix involved in the computation of second-order moment adjustments, contributing to the accurate determination of state covariances.\nL3::AbstractMatrix{T}:   An auxiliary matrix designed to support higher-order moment computations, often necessary for fine-tuning the filtering process.\nP::Int:   The total augmented state dimension, typically defined as the sum of the original state dimension and the square of the state dimension.\n\nThis structure is pivotal for models that incorporate quadratic measurement equations, allowing for the direct integration of quadratic terms into the state estimation process. It facilitates the derivation of augmented transition and measurement matrices, which are essential for achieving improved filtering and smoothing performance in non-linear state-space models.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuadraticKalman.QKFOutput","page":"API Reference","title":"QuadraticKalman.QKFOutput","text":"QKFOutput{T<:Real}\n\nCombined container for both filtering and smoothing outputs from the Quadratic Kalman algorithm.\n\nThis type encapsulates the results of the forward filtering pass—where state estimates and associated covariances are computed recursively based solely on past and present observations—and the subsequent backward smoothing pass that refines these estimates by incorporating future observations. The unified structure provides a clear and convenient interface for diagnostic analysis, visualization, and further model-based inference tasks.\n\nFields\n\nfilter::FilterOutput{T}: Contains the outputs of the filtering process, such as the filtered log-likelihood, state estimates, and covariance matrices at each time step. These results represent the model’s estimates obtained in real time as the data was observed.\nsmoother::SmootherOutput{T}: Contains the outputs of the smoothing process, which refines and improves upon the filter results by leveraging information from the entire observation sequence. This typically includes the smoothed state estimates and corresponding covariance matrices, providing a more accurate reconstruction of the underlying state dynamics.\n\nDetails\n\nUsing the QKFOutput structure, users can conveniently access both the instantaneous (filtering) and retrospectively improved (smoothing) estimates, making it easier to perform post-hoc analysis, diagnostics, or forecasting.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuadraticKalman.FilterOutput","page":"API Reference","title":"QuadraticKalman.FilterOutput","text":"FilterOutput{T<:Real}\n\nA container for the outputs produced by the Quadratic Kalman Filter applied to state-space models with quadratic measurement equations. This structure organizes and stores all key filtering results, facilitating subsequent analysis, diagnostics, or visualization. \n\nFields:   • llt::Vector{T}        A vector containing the log-likelihood values computed at each time step.   • Ztt::Matrix{T}        A matrix representing the filtered state estimates at the current time step.   • Ptt::Array{T,3}        A 3-dimensional array containing the error covariance matrices corresponding to the filtered state estimates.   • Yttm1::Union{Vector{T}, Matrix{T}}       The one-step-ahead (t-1) predicted measurements; it can be a vector for univariate cases or a matrix for multivariate cases.   • Mttm1::Array{T,3}        A 3-dimensional array holding auxiliary statistics from the filtering process.   • Kt::Array{T,3}        A 3-dimensional array of Kalman gain matrices computed at each filter update.   • Zttm1::Matrix{T}        A matrix of the one-step-ahead state predictions (prior estimates).   • Pttm1::Array{T,3}        A 3-dimensional array representing the error covariance matrices for the one-step-ahead state predictions.\n\nUsage:     This structure is used to encapsulate all relevant outputs from the Quadratic Kalman Filter, ensuring that users can easily access and work with the filtered estimates, prediction errors, and associated metrics that describe the performance of the filtering process.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuadraticKalman.SmootherOutput","page":"API Reference","title":"QuadraticKalman.SmootherOutput","text":"SmootherOutput{T<:Real}\n\nContainer for outputs from the Quadratic Kalman Smoother. This structure encapsulates the results produced by the smoothing algorithm, which refines state estimates by incorporating information from both past and future observations. The smoother typically yields more accurate state estimates and associated uncertainty quantification than the filter alone.\n\nFields\n\nZ_smooth::Matrix{T}: A matrix containing the smoothed state estimates. The matrix dimensions are P × (T̄+1), where P represents the dimension of the state vector and T̄+1 denotes the number of time steps.\nP_smooth::Array{T,3}: A three-dimensional array holding the smoothed covariance matrices. Each slice P_smooth[:, :, t] corresponds to the covariance estimate for the state at time step t, with overall dimensions P × P × (T̄+1).\n\nDetails\n\nThe smoothed states and covariances are calculated using the Quadratic Kalman Smoother, which enhances the filtering results by backward recursion. This allows for improved state estimation by considering future as well as past measurements. The structure is essential for diagnostic checks and subsequent analyses in applications where state estimation uncertainty plays a critical role.\n\n\n\n\n\n","category":"type"},{"location":"api/#Plotting-Types","page":"API Reference","title":"Plotting Types","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"KalmanFilterTruthPlot\nKalmanSmootherTruthPlot \nKalmanFilterPlot\nKalmanSmootherPlot","category":"page"},{"location":"api/#QuadraticKalman.KalmanFilterTruthPlot","page":"API Reference","title":"QuadraticKalman.KalmanFilterTruthPlot","text":"KalmanFilterTruthPlot{T,M<:FilterOutput{<:Real}}\n\nA type for plotting Kalman filter results against true states.\n\nFields\n\ntrue_states::T: The true state values to compare against\nresults::M: The output from running the Kalman filter (FilterOutput)\n\nThis type is used internally by the plotting recipes to create comparison plots between the true states and the Kalman filter estimates, including confidence intervals.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuadraticKalman.KalmanSmootherTruthPlot","page":"API Reference","title":"QuadraticKalman.KalmanSmootherTruthPlot","text":"KalmanSmootherTruthPlot{T,M<:SmootherOutput{<:Real}}\n\nA type for plotting Kalman smoother results against true states.\n\nFields\n\ntrue_states::T: An N×T_bar matrix representing the actual underlying state values, X_t, that the model is attempting to filter. Each column corresponds to the state at a specific time step.\nresults::M: The output from running the Kalman smoother, provided as a SmootherOutput, which includes the smoothed state estimates and associated covariance matrices.\n\nThis type is used internally by the plotting recipes to create comparison plots between the true states and the Kalman smoother estimates. The plots typically display:\n\nThe true state trajectories (as represented by the N×T_bar matrix of X_t values).\nThe smoother’s state estimates along with confidence intervals,\n\nthus facilitating a visual diagnostic of the smoother's performance in recovering the true state dynamics.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuadraticKalman.KalmanFilterPlot","page":"API Reference","title":"QuadraticKalman.KalmanFilterPlot","text":"KalmanFilterPlot{M<:FilterOutput{<:Real}}\n\nAn abstraction for constructing detailed visualizations of Kalman filter outcomes. This type is designed to encapsulate all necessary components for plotting the evolution of state estimates, along with the corresponding uncertainty measures, over time. It serves as a central piece within the plotting recipes framework, enabling users to create diagnostic graphics that compare filtered state trajectories against observed data, thereby providing deep insights into the performance and reliability of the Kalman filter.\n\nFields\n\nresults::M: The filtering results computed from a Kalman filter run, expected to be an instance of FilterOutput. This container typically includes:\nFiltered state estimates (Z_tt): The real-time estimates of the states.\nCovariance matrices (P_tt): The corresponding error covariances associated with the state estimates.\nLog-likelihood values (ll_t): Metrics that indicate the goodness-of-fit at each time step.\nSupplementary outputs such as one-step-ahead predictions and other auxiliary statistics necessary for an in-depth analysis of the filtering process.\n\nDetails\n\nThis type is intended for internal use by the plotting recipes module to standardize and streamline the visualization process. Its role is to facilitate the generation of clear and informative plots that not only display the state estimates but also visually represent the associated uncertainty through confidence intervals. This makes it easier to assess the dynamic behavior of the filter, detect potential issues, and diagnose problems related to model fit and convergence.\n\nThe comprehensive documentation provided here ensures that users extending or interfacing with the plotting system will have a complete understanding of the type's purpose and structure, thereby enhancing the overall diagnostic workflow.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuadraticKalman.KalmanSmootherPlot","page":"API Reference","title":"QuadraticKalman.KalmanSmootherPlot","text":"KalmanSmootherPlot{M<:SmootherOutput{<:Real}}\n\nA container for generating visualizations of Kalman smoother outputs. This type encapsulates the results of the smoother, which typically include smoothed state estimates and the corresponding covariance matrices, providing a unified interface for plotting these outputs along with their confidence intervals.\n\nFields\n\nresults::M: An instance of SmootherOutput that contains:\nZ_smooth: A matrix of the smoothed state estimates.\nP_smooth: A three-dimensional array of the smoothed state covariances.\nThese outputs are generated by executing a backward recursion that refines state estimates using future information.\n\nUsage\n\nThis type is used internally by the plotting recipes to produce diagnostic plots that display the smoother’s performance. The standard visualizations enable users to visually compare the smoothed state trajectories against true state values (or other benchmarks), with uncertainty represented as confidence intervals. This facilitates a detailed analysis of the model’s estimation efficiency and convergence properties.\n\nDetails\n\nBy encapsulating the smoother results, KalmanSmootherPlot simplifies the integration of smoothing diagnostics into the plotting framework. The associated plots typically illustrate:\n\nThe estimated state trajectories over time.\nThe uncertainty in these estimates, often depicted using shaded regions corresponding to a 95% confidence interval.\n\nThis enhanced visualization aids in assessing the accuracy and reliability of the smoothing procedure.\n\n\n\n\n\n","category":"type"},{"location":"api/#Functions","page":"API Reference","title":"Functions","text":"","category":"section"},{"location":"api/#Filtering-and-Smoothing","page":"API Reference","title":"Filtering and Smoothing","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"qkf_filter\nqkf_filter!\nqkf_smoother\nqkf_smoother!\nqkf","category":"page"},{"location":"api/#QuadraticKalman.qkf_filter","page":"API Reference","title":"QuadraticKalman.qkf_filter","text":"qkf_filter(data::QKData{T1,1}, model::QKModel{T,T2})\n\nRun the Quadratic Kalman Filter (QKF) on a time series of length T̄,  returning a new set of result arrays (out-of-place).\n\nDescription\n\nThis function implements the same quadratic Kalman filter recursion  as qkf_filter!, but instead of updating arrays in-place, it allocates  new arrays for predictions, updates, and outputs. This can be simpler to  use in contexts where you don't want to mutate or reuse data and model,  but it may be less memory-efficient for large-scale problems.\n\nAt each time step, it performs:\n\nState Prediction (predict_Z_tt / predict_P_tt)\nMeasurement Prediction (predict_Y_tt / predict_M_ttm1)\nKalman Gain Computation (compute_K_t)\nState & Covariance Update (update_Z_tt, update_P_tt)\nPSD Correction (correct_Zₜₜ)\nLog-Likelihood computation.\n\nArguments\n\ndata::QKData{T1,1}   Same structure as in qkf_filter!, with fields:\nY::Vector{T1}, T̄::Int, M::Int.\nmodel::QKModel{T,T2}   Same parameter structure as in qkf_filter!, with fields:\nN::Int, P::Int, μ̃ᵘ, Σ̃ᵘ, etc.\n\nReturn\n\nA named tuple with fields:\n\nll_t::Vector{Float64}   Per-time-step log-likelihoods (size = T̄).\nZ_tt::Array{T,3}   The filtered state at each time step (dimensions (T, P, T̄+1) in your usage).\nP_tt::Array{T,4}   The filtered state covariance array.\nY_ttm1::Vector{T}   Predicted measurement for each step.\nM_ttm1::Array{T,4}   Predicted measurement covariances.\nK_t::Array{T,4}   The Kalman gain for each time step.\nZ_ttm1::Array{T,3}   One-step-ahead predicted states.\nP_ttm1::Array{T,4}   One-step-ahead predicted covariances.\n\nDetails\n\nInitialization:\nCreates new arrays for Z_tt and P_tt and sets the initial state  to aug_mean and aug_cov.\nTime Loop: \nPrediction: predict_Z_tt, predict_P_tt.\nMeasurement: predict_Y_tt, predict_M_ttm1.\nGain & Update: compute_K_t, update_Z_tt, update_P_tt.\nCorrection: correct_Z_tt for PSD.\nLikelihood: compute_loglik.\nNo In-Place Mutation:\nEach step returns fresh arrays; original inputs are not modified.\n\nExample\n\ndata = QKData(Y, M=measurement_dim, T̄=length(Y)-1)\nmodel = QKModel(...)\nresult = qkf_filter(data, model)\n\n@show result.ll_t\n@show result.Z_tt[:, end]   # final state\n\n\n\n\n\n","category":"function"},{"location":"api/#QuadraticKalman.qkf_filter!","page":"API Reference","title":"QuadraticKalman.qkf_filter!","text":"qkf_filter!(data::QKData{T1,1}, model::QKModel{T,T2})\n\nRun the Quadratic Kalman Filter (QKF) on a time series of length T̄, modifying the result in-place.\n\nDescription\n\nThis function implements a Kalman-like recursive filter where the state  vector Zₜ includes not only the usual mean component xₜ but also  terms for the second-moment (x xᵀ)ₜ, making it a quadratic extension.  At each time step, it performs:\n\nState Prediction (predict_Z_ttm1! / predict_P_ttm1!)\nMeasurement Prediction (predict_Y_ttm1! / predict_M_ttm1!)\nKalman Gain Computation (compute_K_t!)\nState & Covariance Update (update_Z_tt!, update_P_tt!)\nPSD Correction (correct_Z_tt!)\nLog-Likelihood computation for the current innovation.\n\nUnlike the non-mutating version (qkf_filter), this function reuses  and mutates internal arrays and data structures in-place, which can  improve performance and reduce memory allocations.\n\nArguments\n\ndata::QKData{T1,1}   A structure holding:\nY::Vector{T1} of length T̄+1, containing observations.  Typically, Y[1] is an initial placeholder and Y[2..end]  are the actual measurements.\nT_bar::Int the total number of time steps (excluding index 0).\nM::Int the dimension of the measurement at each time step.\nmodel::QKModel{T,T2}   A parameter structure holding:\nN::Int: State dimension (for the mean part).\nP::Int: Dimension of the augmented \"quadratic\" state  (P = N + N(N+1)/2).\nμ_aug, Σ_aug: The unconditional mean and covariance used for  initialization.\nAdditional model matrices or functions (e.g., Φ_aug, B_aug, A, V)  accessed via subroutines.\n\nReturn\n\nA named tuple with fields:\n\nll_t::Vector{Float64}   The per-time-step log-likelihoods (size = T̄).\nZ_tt::Array{T,3}   The filtered state at each time step. Dimensions: (T, P, T̄+1) in your  specific code (or (P, T̄+1) in a more generic version).\nPₜₜ::Array{T,4}   The filtered state covariance array. Dimensions often (T, P, P, T̄+1)  in your code.\nYₜₜ₋₁::Vector{T}   The predicted measurement at each time step (size = T̄).\nM_ttm1::Array{T,4}   The predicted measurement covariance, dimensions (T, M, M, T̄).\nK_t::Array{T,4}   The Kalman gain for each time step, (T, P, M, T̄).\nZₜₜ₋₁::Array{T,3}   One-step-ahead predicted states.\nPₜₜ₋₁::Array{T,4}   One-step-ahead predicted covariances.\nΣ_ttm1::Array{T,4}   Any intermediate covariance terms used for prediction.\n\nDetails\n\nInitialization: \nZ_tt[:, 1] .= μ̃ᵘ and P_tt[:,:,1] .= Σ̃ᵘ.\nRecursive Steps (for t in 1:T̄):\nPrediction: predict_Z_ttm1! / predict_P_ttm1!.\nMeasurement: predict_Y_ttm1! / predict_M_ttm1!.\nGain & Update: compute_K_t!, then update_Z_tt! / update_P_tt!. \nCorrection: correct_Z_tt! clamps negative eigenvalues  for PSD.\nLikelihood: compute_loglik! appends the log-likelihood.\nPositive Semidefinite Correction: \nNegative eigenvalues introduced by approximation are set to zero.\n\nExample\n\ndata = QKData(Y, M=measurement_dim, T̄=length(Y)-1)\nmodel = QKModel(...)\nresult = qkf_filter!(data, model)\n\n@show result.ll_t\n@show result.Z_tt[:, end]   # final state\n\n\n\n\n\nqkf_filter!(data::QKData{T1,1}, model::QKModel{T,T2})\n\nRun the Quadratic Kalman Filter (QKF) on a time series of length T̄.\n\nDescription\n\nThis function implements a Kalman-like recursive filter where the state  vector Z_t includes not only the usual mean component xₜ but also  terms for the second-moment (x xᵀ)ₜ, making it a quadratic extension.  At each time step, it performs:\n\nState Prediction (predict_Z_ttm1 / predict_P_ttm1)\nMeasurement Prediction (predict_Y_ttm1 / predict_M_ttm1)\nKalman Gain Computation (compute_K_t)\nState & Covariance Update (update_Zₜₜ!, update_Pₜₜ!)\nPSD Correction: Ensures the implied covariance is positive semidefinite  by clamping negative eigenvalues via correct_Zₜₜ!.\nLog-Likelihood computation for the current innovation.\n\nThe filter stores and returns the entire history of filtered states, covariances, predicted measurements, and related arrays. \n\nArguments\n\ndata::QKData{T1,1}   A structure holding:\nY::Vector{T1} of length T_bar+1, which contains observations  (Y[1] is unused or some initial placeholder, and Y[2..end] are the actual measurements).\nT_bar::Int the total number of time steps (excluding index 0).\nM::Int the dimension of the measurement at each time step.\nmodel::QKModel{T,T2}   A parameter structure holding:\nN::Int: State dimension (for the mean part).\nP::Int: Dimension of the augmented \"quadratic\" state vector  (P = N + N(N+1)/2).\naug_mean, aug_cov: The unconditional mean and covariance used for initialization.\nAdditional model matrices or functions (e.g., Phi_aug, B_aug, A, V),  typically accessed via separate predict/update subroutines.\n\nReturn\n\nA named tuple with fields:\n\nll_t::Vector{Float64}   The per-time-step log-likelihoods of the innovations (size = T_bar).\nZ_tt::Matrix{T}   The updated (\"filtered\") state at each time step. Dimensions: (P, T_bar+1),  where column k corresponds to time index k-1.\nP_tt::Array{T,3}   The updated (\"filtered\") state covariance array (or the augmented second-moment  representation) at each time step. Dimensions: (P, P, T_bar+1.\nY_ttm1::Vector{T}   The predicted measurement at each time step (size = T_bar).\nM_ttm1::Array{T,3}   The predicted measurement covariance at each time step (dimensions: (M, M, T_bar)).\nK_t::Array{T,3}   The Kalman gain at each time step (P, M, T_bar).\nZ_ttm1::Matrix{T}   The one-step-ahead predicted state (dimensions: (P, T_bar)).\nP_ttm1::Array{T,4}   The one-step-ahead predicted covariance (dimensions: (P, P, T_bar)).\nΣ_ttm1::Array{T,4}   Any intermediate state-dependent covariance terms added during prediction  (dimensions: (P, P, T_bar)).\n\nDetails\n\nInitialization:  \nZ_tt[:,1] .= aug_mean and P_tt[:,:,1] .= aug_cov, representing the state at time 0.\nTime Loop (for t in 1:T_bar):  \nPredict step: \npredict_Z_ttm1 sets Z_ttm1[:,t] from Z_tt[:,t].\npredict_P_ttm1 sets P_ttm1[:,:,t] from P_tt[:,:,t].\nMeasurement step: \npredict_Y_ttm1 computes Y_ttm1[t] from Z_ttm1[:,t].\npredict_M_ttm1 updates M_ttm1[:,:,t].\nGain & Update:\ncompute_K_t obtains the Kalman gain K_t[:,:,t].\nupdate_Z_tt and update_P_tt yield the next Z_tt[:,t+1] and P_tt[:,:,t+1].\nCorrection:  \ncorrect_Z_tt clamps negative eigenvalues in the implied covariance portion  of Z_tt to ensure PSD. \nLikelihood:\ncompute_loglik appends/logs the innovation-based log-likelihood  in ll_t[t].\nPositive Semidefinite Correction:\nBecause the filter tracks [X Xᵀ] - X Xᵀᵀ as a covariance block, it can  become indefinite due to linearization or numerical issues. We enforce  PSD by zeroing out negative eigenvalues in correct_Z_tt.\nThis step is not strictly differentiable at eigenvalues crossing zero.  If you need AD through the filter, consider an alternative correction  or a custom adjoint.\n\nExample\n\n```julia data = QKData(Y, M=measurementdim, Tbar=length(Y)-1) model = QKModel( ... )   # set up your model\n\nresult = qkf_filter!(data, model)\n\n@show result.llt @show result.Ztt[:, end]   # final state vector\n\n\n\n\n\n","category":"function"},{"location":"api/#QuadraticKalman.qkf_smoother","page":"API Reference","title":"QuadraticKalman.qkf_smoother","text":"qkf_smoother( Z, P, Z_pred, P_pred, T_bar, H_aug, G_aug, Φ_aug, dof ) -> (Z_smooth, P_smooth)\n\nOut-of-place version of the QKF smoother. Returns new arrays rather than overwriting the input ones.\n\nDescription\n\nIdentical to qkfsmoother! in logic, but it allocates new arrays Zsmooth and P_smooth for the smoothed results. This is often simpler for AD frameworks that do not allow in-place mutation of arrays.\n\nReturns\n\nZ_smooth::Matrix{T}: (P × (T_bar+1)) smoothed states\nP_smooth::Array{T,3}: (P × P × (T_bar+1)) smoothed covariances\n\nExample\n\nZ_smooth, P_smooth = qkf_smoother(Z, P, Z_pred, P_pred, T_bar, Hn, Gn, H_aug, Φ_aug, n)\n\n\n\n\n\nqkf_smoother(filter_output::FilterOutput{T}, model::QKModel{T,T2}) where {T<:Real, T2<:Real}\n\nPerforms out-of-place backward smoothing for the Quadratic Kalman Filter (QKF) using filtering outputs. This function refines the state estimates produced during filtering by incorporating future observations through a backward smoothing pass.\n\nArguments\n\nfilteroutput::FilterOutput{T}: A container holding the outputs from the filtering phase, including:   • Ztt: A matrix of filtered augmented state estimates.   • Ptt: An array of filtered state covariances.   • Zttm1: A matrix containing the one-step-ahead predicted states.   • P_ttm1: An array containing the one-step-ahead predicted state covariances.\nmodel::QKModel{T,T2}: A model specification that provides the necessary parameters for the smoothing process. The model includes an aug_state field which is unpacked to retrieve:   • Haug: The augmented measurement selection matrix.   • Gaug: The augmented duplication matrix used for handling quadratic forms.   • Phi_aug: The augmented state transition matrix. Additionally, the state field is used to extract the dimensionality (N) of the state.\n\nDetails\n\nThis function first creates copies of the filtered state and covariance estimates to prevent modification of the original filtering outputs. It then invokes the in-place smoother routine (qkf_smoother!) on these copies using the one-step-ahead predicted values and the model's parameters. The final smoothed results are wrapped in a SmootherOutput struct and returned as fresh copies, which is particularly important for compatibility with automatic differentiation (AD) workflows.\n\nReturns\n\nSmootherOutput: A composite structure containing:   • Zsmooth: A matrix of smoothed augmented state estimates.   • Psmooth: An array of smoothed state covariance matrices.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuadraticKalman.qkf_smoother!","page":"API Reference","title":"QuadraticKalman.qkf_smoother!","text":"qkf_smoother!(\n    Z::AbstractMatrix{T},      # Filtered states   (P × (T_bar+1))\n    P::AbstractArray{T, 3},    # Filtered covariances (P × P × (T_bar+1))\n    Z_pred::AbstractMatrix{T}, # One-step-ahead predicted states (P × T_bar)\n    P_pred::AbstractArray{T,3},\n    T_bar::Int,\n    Hn::Matrix{T},  Gn::Matrix{T},  H_aug::Matrix{T},  Φ_aug::Matrix{T},\n    dof::Int\n) where {T<:Real}\n\nPerform in-place backward smoothing for the Quadratic Kalman Filter (QKF).\n\nDescription\n\nGiven the forward-filtered estimates (Z, P) from t=1..T_bar, plus the  one-step-ahead predictions (Z_pred, P_pred) and the special matrices  (Haug, Gaug) that handle the dimension reduction via  Vech(·)/Vec(·), this function computes Z[:,t] and P[:,:,t] for  t = T_bar-1 .. 1 in backward fashion to produce the smoothed estimates  (Zₜ|Tbar, PZₜ|Tbar).  \n\nMathematical Form (Backward Pass)\n\nCompute   Fₜ = (H̃ₙPᵗ|ᵗᶻH̃ₙ')(H̃ₙΦ̃G̃ₙ)'(H̃ₙPᵗ⁺¹|ᵗᶻH̃ₙ')⁻¹ but implemented via solves (rather than explicit inverses) for numerical stability.\nThen update (in H̃ₙ-transformed space): H̃ₙZₜ|ₜ = H̃ₙZₜ|ₜ + Fₜ(H̃ₙZₜ₊₁|ₜ - H̃ₙZₜ₊₁|ₜ)\nAnd similarly for the covariance: (H̃ₙPᵗ|ᵀᶻH̃ₙ') = (H̃ₙPᵗ|ᵗᶻH̃ₙ') + Fₜ[(H̃ₙPᵗ⁺¹|ᵀᶻH̃ₙ') - (H̃ₙPᵗ⁺¹|ᵗᶻH̃ₙ')]Fₜ'\nFinally, transform back to get Zₜ|T and Pᵗ|ᵀᶻ in the full (Vec/augmented) space if necessary.\n\nArguments\n\nZ::AbstractMatrix{T}: On entry, Z[:,t] = Zₜ|T for each t. On exit, it will contain the smoothed states Zₜ|T.\nP::AbstractArray{T,3}: On entry, P[:,:,t] = Pᵗ|ᵀᶻ.  On exit, P[:,:,t] = Pᵗ|ᵀᶻ.\nZ_pred::AbstractMatrix{T}, P_pred::AbstractArray{T,3}:  The one-step-ahead predicted states/covariances from the forward pass, i.e. Z_pred[:,t] = Zₜ|ₜ, P_pred[:,:,t] = P^Zₜ|ₜ.\nT_bar::Int: Total time steps (excluding time 0).\nHn::Matrix{T}, Gn::Matrix{T}: The selection/duplication operators  for Vec/Vech transforms of block (x xᵀ). Usually size (n(n+1) × n(n+3)/2) or similarly.\nH_aug::Matrix{T}, Φ_aug::Matrix{T}: The augmented versions  (Haug, Gaug) used in the QKF recursion.\ndof::Int: Dimension parameter (often n or P). Adjust to your model.\n\nNotes\n\nThis function runs backward from t = T_bar-1 down to t = 1, using  the final values (Z[:, T_bar], P[:,:, T_bar]) as the terminal condition  (Z_{T_bar|T_bar}, P^Z_{T_bar|T_bar}).\nIf your AD library supports destructive updates, this approach should  be AD-friendly; if not, consider the out-of-place version qkf_smoother.\n\nExample\n\nSuppose you already ran the forward filter, so you have:     Z, P, Zpred, Ppred, plus your special matrices.\n\nqkf_smoother!(Z, P, Z_pred, P_pred, T_bar, Hn, Gn, H_aug, Φ_aug, n)\n\n\n\n\n\nqkf_smoother!(filter_output::FilterOutput{T}, model::QKModel{T,T2}) where {T<:Real, T2<:Real}\n\nPerforms in-place backward smoothing for a Quadratic Kalman Filter (QKF) using the outputs obtained during filtering.\n\nThis function refines the filtered state estimates and covariance matrices by incorporating future observations, thereby producing a set of smoothed estimates. It operates by first extracting the filtered states (Ztt) and their associated covariances (Ptt), as well as the one-step-ahead predictions (Zttm1 and Pttm1) from the given FilterOutput structure. It then unpacks the augmented state parameters (Haug, Gaug, Phi_aug) along with the state dimension (N) from the QKModel. The function makes local copies of the filtered estimates to avoid any modification of the original filtering results, and then calls the lower-level in-place smoothing routine to update these copies using the one-step-ahead predictions and the model parameters. The smoothed states and covariances are finally encapsulated into a SmootherOutput structure, which is returned.\n\nParameters:\n\nfilteroutput: A FilterOutput instance containing:   • Ztt    :: Matrix of filtered augmented state estimates for time steps 0 to T̄.   • Ptt    :: Array of filtered state covariance matrices.   • Zttm1  :: Matrix of one-step-ahead predicted augmented states.   • P_ttm1  :: Array of one-step-ahead predicted covariance matrices.\nmodel: A QKModel instance providing the necessary model parameters for smoothing, including:   • augstate: A structure containing:       - Haug  :: The augmented measurement selection matrix.       - Gaug  :: The augmented duplication matrix for handling quadratic forms.       - Phiaug:: The augmented state transition matrix.   • state: The dimension (N) of the state vector.\n\nReturns:\n\nA SmootherOutput structure containing:   • Zsmooth :: Matrix of smoothed augmented state estimates.   • Psmooth :: Array of smoothed state covariance matrices.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuadraticKalman.qkf","page":"API Reference","title":"QuadraticKalman.qkf","text":"qkf(model::QKModel{T,T2}, data::QKData{T1,N}) where {T1<:Real, T<:Real, T2<:Real, N}\n\nExecute the full Quadratic Kalman Filter (QKF) process by combining both the filtering and backward smoothing stages. This function first applies the filtering routine to generate real-time state estimates and then refines these estimates using the smoother to incorporate information from future observations. The resulting output is a composite object that  encapsulates both the filtered and smoothed results.\n\nParameters:\n\nmodel::QKModel{T,T2}: A model specification that includes the system dynamics, state transition parameters, and the augmented state representation. This object provides all necessary configurations to perform the QKF.\ndata::QKData{T1,N}: A data container comprising the observed time series measurements, formatted appropriately for the QKF. The parameter N indicates the dimension of the state vector, and T1 denotes the numerical type of the data.\n\nProcess:\n\nFiltering Stage: The function invokes qkf_filter with the provided data and model to compute the filtered state estimates and error covariances.\nSmoothing Stage: It then calls qkf_smoother to perform backward smoothing on the filtered results, enhancing the  state estimates by leveraging future information.\n\nReturns:\n\nQKFOutput{T}: A composite output object that bundles both filtering and smoothing results. This output includes:   • filteroutput: The results from the filtering phase, containing state estimates and covariances.   • smootheroutput: The refined state estimates obtained after applying the smoother.\n\nThis combined output is useful for subsequent analysis, diagnostics, and visualization of the QKF performance.\n\n\n\n\n\nqkf(data::QKData{T1,N}, model::QKModel{T,T2}) where {T1<:Real, T<:Real, T2<:Real, N}\n\nThis function offers a backwards-compatible interface to the Quadratic Kalman Filter (QKF) by accepting the data and model arguments in a reversed order compared to the standard interface. Typically, the preferred order is to pass the model first followed by the data. This method ensures that legacy code that follows the old argument order still functions correctly.\n\nParameters:\n\ndata::QKData{T1,N}: An instance containing the observed time series data formatted for the QKF. The data structure organizes the measurements and any associated time indices to be processed by the filter.\nmodel::QKModel{T,T2}: An instance containing the model specifications which include the system dynamics, the augmented state representation, and all relevant parameters required to perform the filtering and smoothing operations.\n\nReturns:\n\nQKFOutput{T}: A composite output object that includes both the filtering results and the smoothed state estimates. This output encapsulates all intermediate steps and final results computed by invoking the standard qkf function with the proper argument order.\n\nNote:    This reversed argument order function is maintained solely for backwards compatibility. Internally, it simply calls    qkf(model, data) to ensure that the original processing logic remains unchanged.\n\n\n\n\n\n","category":"function"},{"location":"api/#Convenience-Functions","page":"API Reference","title":"Convenience Functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"get_measurement\nqkf_negloglik\nmodel_to_params\nparams_to_model","category":"page"},{"location":"api/#QuadraticKalman.get_measurement","page":"API Reference","title":"QuadraticKalman.get_measurement","text":"get_measurement(data::QKData{T,N}, t::Int) where {T<:Real, N}\n\nExtract measurement at time t from QKData.  For vector data returns a scalar, for matrix data returns a vector.\n\nArguments\n\ndata::QKData{T,N}: Data structure\nt::Int: Time index (1-based)\n\nReturns\n\nFor N=1: Single measurement Y[t]\nFor N=2: Vector of measurements Y[:,t]\n\nThrows\n\nArgumentError if t is out of bounds\n\n\n\n\n\n","category":"function"},{"location":"api/#QuadraticKalman.qkf_negloglik","page":"API Reference","title":"QuadraticKalman.qkf_negloglik","text":"qkf_negloglik(params::Vector{T}, data::QKData, N::Int, M::Int) where T<:Real -> Real\n\nCompute the negative log-likelihood for a Quadratic Kalman Filter model given parameters and data.\n\nArguments\n\nparams::Vector{T}: Vector of model parameters to be converted into a QKModel\ndata::QKData: Data container with observations and optional initial conditions\nN::Int: Dimension of the state vector\nM::Int: Dimension of the measurement vector\n\nReturns\n\nThe negative log-likelihood value computed by:\n\nConverting parameters to a QKModel\nRunning the Kalman filter\nTaking the negative sum of the per-period log-likelihoods\n\nNote\n\nThis function is typically used as an objective function for maximum likelihood estimation, where the goal is to minimize the negative log-likelihood.\n\nFor optimization, you may want to wrap this function with N, M and data specified:\n\nnegloglik(params) = qkf_negloglik(params, data, N, M)\n\n\n\n\n\n","category":"function"},{"location":"api/#QuadraticKalman.model_to_params","page":"API Reference","title":"QuadraticKalman.model_to_params","text":"model_to_params(model::QKModel{T, T2}) where {T<:Real, T2}\n\nConvert a QKModel object into a vector of unconstrained parameters.\n\nThe ordering of the parameters is as follows:\n\nState parameters:\nmu (length N)\nPhi (N×N, stored columnwise)\nUnconstrained parameters for the state noise scaling factor Ω: For each row i = 1,...,N and column j = 1,...,i (i.e. the lower–triangular part):\nIf i == j: the parameter is log(Ω[i,i])\nElse: the parameter is Ω[i,j]\nMeasurement parameters:\nA (length M)\nB (M×N, stored columnwise)\nC (a vector of M matrices; each matrix is N×N and is flattened columnwise)\nUnconstrained parameters for the measurement noise scaling factor D: For each row i = 1,...,M and column j = 1,...,i:\nIf i == j: the parameter is log(D[i,i])\nElse: the parameter is D[i,j]\nalpha (M×M, stored columnwise)\n\nReturns\n\nA vector of unconstrained parameters that, when passed to params_to_model, reconstructs the original QKModel.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuadraticKalman.params_to_model","page":"API Reference","title":"QuadraticKalman.params_to_model","text":"params_to_model(params::Vector{T}, N::Int, M::Int) where T<:Real -> QKModel\n\nConvert a parameter vector into a QKModel object with state and measurement parameters.\n\nArguments\n\nparams::Vector{T}: A vector of unconstrained parameters.\nN::Int: Dimension of the state vector.\nM::Int: Dimension of the measurement vector.\n\nReturns\n\nA QKModel object containing:\n\nState parameters: (mu, Phi, Omega)   where the state equation is     Xₜ = μ + Φ Xₜ₋₁ + Omega εₜ. Here, Omega is constructed as Omega = Dstate * Dstate′, with D_state a lower–triangular matrix (of size N×N) whose diagonal entries are positive.\nMeasurement parameters: (A, B, C, D, α)   where the measurement equation is     Yₜ = A + B Xₜ + α Yₜ₋₁ + ∑₍ᵢ₌₁₎ᴹ Xₜ′ Cᵢ Xₜ + D εₜ. Here, D is constructed as D = Dmeas * Dmeas′, with D_meas a lower–triangular matrix (of size M×M) whose diagonal entries are positive.\nAugmented state parameters and model moments (computed via helper functions).\n\nParameter vector layout\n\nThe parameter vector is assumed to contain:\n\nState parameters:\nFirst N entries: state mean mu.\nNext N^2 entries: entries of Phi (stored columnwise).\nNext N(N+1)/2 entries: unconstrained parameters for D_state (used to form Omega).\nMeasurement parameters:\nNext M entries: A.\nNext M×N entries: entries of B (reshaped as an M×N matrix).\nNext M×N^2 entries: entries for C. (Interpreted as M matrices of size N×N.)\nNext M(M+1)/2 entries: unconstrained parameters for D_meas (used to form D).\nFinal M×M entries: entries of α (reshaped as an M×M matrix).\n\nTotal expected length:\n\nN + N^2 + N(N+1)/2  +  M + M×N + M×N^2 + M(M+1)/2 + M^2\n\n\n\n\n\n","category":"function"},{"location":"api/#Plotting-API","page":"API Reference","title":"Plotting API","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"kalman_filter_truth_plot\nkalman_smoother_truth_plot\nkalman_filter_plot\nkalman_smoother_plot","category":"page"},{"location":"api/#QuadraticKalman.kalman_filter_truth_plot","page":"API Reference","title":"QuadraticKalman.kalman_filter_truth_plot","text":"kalman_filter_truth_plot(X, results)\n\nCreate a plot comparing true states with Kalman filter estimates.\n\nArguments\n\nX: Matrix of true state values (N×T)\nresults: FilterOutput object containing filtered state estimates\n\nReturns\n\nA plot showing true states, filtered estimates, and confidence intervals\n\n\n\n\n\n","category":"function"},{"location":"api/#QuadraticKalman.kalman_smoother_truth_plot","page":"API Reference","title":"QuadraticKalman.kalman_smoother_truth_plot","text":"kalman_smoother_truth_plot(X, results)\n\nCreate a plot comparing true states with Kalman smoother estimates.\n\nArguments\n\nX: Matrix of true state values (N×T)\nresults: SmootherOutput object containing smoothed state estimates\n\nReturns\n\nA plot showing true states, smoothed estimates, and confidence intervals\n\n\n\n\n\n","category":"function"},{"location":"api/#QuadraticKalman.kalman_filter_plot","page":"API Reference","title":"QuadraticKalman.kalman_filter_plot","text":"kalman_filter_plot(results)\n\nCreate a plot of Kalman filter estimates.\n\nArguments\n\nresults: FilterOutput object containing filtered state estimates\n\nReturns\n\nA plot showing filtered estimates and confidence intervals\n\n\n\n\n\n","category":"function"},{"location":"api/#QuadraticKalman.kalman_smoother_plot","page":"API Reference","title":"QuadraticKalman.kalman_smoother_plot","text":"kalman_smoother_plot(results)\n\nCreate a plot of Kalman smoother estimates.\n\nArguments\n\nresults: SmootherOutput object containing smoothed state estimates\n\nReturns\n\nA plot showing smoothed estimates and confidence intervals\n\n\n\n\n\n","category":"function"},{"location":"plots/#Plotting-Guide","page":"Plotting Guide","title":"Plotting Guide","text":"","category":"section"},{"location":"plots/","page":"Plotting Guide","title":"Plotting Guide","text":"using QuadraticKalman, Plots\n\n# After running filter/smoother\nkf_truth_plot = kalman_filter_truth_plot(true_states, filter_results)\nplot(kf_truth_plot)\n\n\nks_truth_plot = kalman_smoother_truth_plot(true_states, smoother_results) \nplot(ks_truth_plot)\n\n\nkf_plot = kalman_filter_plot(filter_results)\nplot(kf_plot)\n\nks_plot = kalman_smoother_plot(smoother_results)\nplot(ks_plot)","category":"page"},{"location":"examples/#QuadraticKalman.jl-End-to-End-Example","page":"Examples","title":"QuadraticKalman.jl End-to-End Example","text":"","category":"section"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example demonstrates an end-to-end workflow using QuadraticKalman.jl. In this example we simulate state and observation data, run the Kalman filter and smoother, plot the results, and finally compute the negative log-likelihood along with its gradients.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Pkg\nPkg.activate(\"..\")  # Activate local environment\nPkg.develop(path=\"../../\")  # Relative path to package root\nPkg.instantiate()\n\nusing QuadraticKalman\nusing Random, LinearAlgebra, Statistics, Plots\n\n# Step 1: Set Parameters\n\nN = 2                     # Number of states\nM = 2                     # Number of measurements\nT = 100                   # Number of time periods to simulate\nseed = 2314               # Random seed for reproducibility\nRandom.seed!(seed)\n\n# Generate stable state transition parameters\nPhi = [0.5 0.1; 0.1 0.3]   # Autoregressive (state transition) matrix\nmu = [0.1, 0.2]            # State drift vector\nSigma = [0.6 0.15; 0.15 0.4]  # State noise covariance matrix\nOmega = cholesky(Sigma).L  # Scale for state noise\n\n# Measurement parameters\nA = [0.0, 0.0]             # Measurement drift vector\nB = [1.0 0.0; 0.0 1.0]     # Measurement matrix linking state to observation\nC = [[0.2 0.1; 0.1 0.0],   # Quadratic effect for first measurement\n     [0.0 0.1; 0.1 0.2]]   # Quadratic effect for second measurement\nV = [0.2 0.0; 0.0 0.2]     # Measurement noise covariance matrix\nD = cholesky(V).L          # Scale for measurement noise\nalpha = zeros(M, M)        # Measurement autoregressive matrix","category":"page"},{"location":"examples/#Step-2:-Simulate-States","page":"Examples","title":"Step 2: Simulate States","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"X = zeros(N, T)\nX[:, 1] = (I - Phi) \\ mu   # Initialize state at the unconditional mean\n\nfor t in 1:(T-1)\n    shock = randn(N)\n    X[:, t+1] = mu + Phi * X[:, t] + Omega * shock\nend","category":"page"},{"location":"examples/#Step-3:-Simulate-Observations","page":"Examples","title":"Step 3: Simulate Observations","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Y = zeros(M, T)\n\nfor t in 1:T\n    noise = randn(M)\n    xt = X[:, t]\n\n    # Linear component\n    Y[:, t] = A + B * xt\n\n    # Include autoregressive measurement component if t > 1\n    if t > 1\n        Y[:, t] += alpha * Y[:, t-1]\n    end\n\n    # Add quadratic effects for each measurement\n    for i in 1:M\n        Y[i, t] += xt' * C[i] * xt\n    end\n\n    # Add measurement noise\n    Y[:, t] += D * noise\nend","category":"page"},{"location":"examples/#Step-4:-Define-and-Initialize-the-Model","page":"Examples","title":"Step 4: Define and Initialize the Model","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"model = QKModel(N, M, mu, Phi, Omega, A, B, C, D, alpha)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"QKModel{Float64, Float64}\n  state: StateParams{Float64}\n  meas: MeasParams{Float64}\n  aug_state: AugStateParams{Float64, Float64}\n  moments: Moments{Float64}","category":"page"},{"location":"examples/#Step-5:-Run-the-Filter-and-Smoother","page":"Examples","title":"Step 5: Run the Filter and Smoother","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"data = QKData(Y)\nresults = qkf_filter(data, model)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"FilterOutput{Float64}(...)","category":"page"},{"location":"examples/#Step-6:-Run-the-Smoother","page":"Examples","title":"Step 6: Run the Smoother","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"results_smoother = qkf_smoother(results, model)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"SmootherOutput{Float64}(...)","category":"page"},{"location":"examples/#Display-Log-Likelihood-and-Plot-Results","page":"Examples","title":"Display Log-Likelihood and Plot Results","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"println(\"Filter Log-Likelihood: \", sum(results.ll_t))\n\n\nplot(kalman_filter_truth_plot(X, results))\nplot(kalman_smoother_truth_plot(X, results_smoother))\nplot(kalman_filter_plot(results))\nplot(kalman_smoother_plot(results_smoother))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Filter Log-Likelihood: -263.0625463924433","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Step-7:-Model-Parameter-Conversion-and-Gradient-Analysis","page":"Examples","title":"Step 7: Model-Parameter Conversion and Gradient Analysis","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"params = model_to_params(model)\nmodel_from_params = params_to_model(params, N, M)\n\n\n# Compute negative log-likelihood function for automatic differentiation\nnll(params) = qkf_negloglik(params, data, N, M)\n\nusing ForwardDiff, FiniteDiff\n\ngrad = ForwardDiff.gradient(nll, params)\ngrad_fd = FiniteDiff.finite_difference_gradient(nll, params)\n\nprintln(\"Max absolute difference in gradients: \", maximum(abs.(grad - grad_fd)))\nprintln(\"Hessian condition number: \", cond(ForwardDiff.hessian(nll, params)))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Max absolute difference in gradients: 0.019281279928234474\nHessian condition number: 5.8961011704491535e6","category":"page"},{"location":"examples/#Display-Plots-Properly","page":"Examples","title":"Display Plots Properly","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"p1 = plot(kalman_filter_truth_plot(X, results))\np2 = plot(kalman_smoother_truth_plot(X, results_smoother))\np3 = plot(kalman_filter_plot(results))\np4 = plot(kalman_smoother_plot(results_smoother))\nplot(p1, p2, p3, p4, layout=(2,2), size=(800,600))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"#QuadraticKalman.jl","page":"Home","title":"QuadraticKalman.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package implementing the quadratic Kalman filter and smoother.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"QuadraticKalman\")","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QuadraticKalman.jl implements Kalman filtering and smoothing for state-space models with quadratic measurement equations. It extends standard implementations by handling autoregressive measurement components, performs gradient and Hessian computations with automatic differentiation, and provides efficient parameter-model conversions with high numerical stability.","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using QuadraticKalman, Random, Plots, LinearAlgebra, ForwardDiff, Plots\nRandom.seed!(2314)\n\n# Define model dimensions\nN = 2  # Number of states\nM = 2  # Number of measurements\n\n# Generate state-space parameters\nμ = [0.1, 0.2]                  # State drift vector\nΦ = [0.5 0.1; 0.1 0.3]          # State transition matrix\nΣ = [0.6 0.15; 0.15 0.4]        # State noise covariance matrix\nΩ = cholesky(Σ).L              # Scale for state noise\n\n# Define measurement parameters\nA = [0.0, 0.0]                # Measurement drift vector\nB = [1.0 0.0; 0.0 1.0]        # Measurement matrix\nC = [\n    [0.2 0.1; 0.1 0.0],        # Quadratic effect for first measurement\n    [0.0 0.1; 0.1 0.2]         # Quadratic effect for second measurement\n]\nV = [0.2 0.0; 0.0 0.2]        # Measurement noise covariance matrix\nD = cholesky(V).L             # Scale for measurement noise\nα = zeros(M, M)               # Autoregressive measurement matrix\n\n# For demonstration purposes, simulate dummy measurements\nY = randn(M, 100)  # Replace with actual or simulated data\n\n# Create the model and data objects\nmodel = QKModel(N, M, μ, Φ, Ω, A, B, C, D, α)\ndata = QKData(Y)\n\n# Run the Kalman filter and smoother\nresults_filter = qkf_filter(data, model)\nresults_smoother = qkf_smoother(results_filter, model)\n\n# Compute negative log-likelihood and gradients\nnll(params) = qkf_negloglik(params, data, N, M)\ngrad = ForwardDiff.gradient(nll, params)\nhess = ForwardDiff.hessian(nll, params)\n\n# Plot results\np1 = plot(kalman_filter_truth_plot(Y, results_filter))\np2 = plot(kalman_smoother_truth_plot(Y, results_smoother))\np3 = plot(kalman_filter_plot(results_filter))\n\np4 = plot(kalman_smoother_plot(results_smoother))\nplot(p1, p2, p3, p4, layout=(2,2), size=(800,600))","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MIT License Copyright (c) 2024 David Leather","category":"page"},{"location":"","page":"Home","title":"Home","text":"Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"examples_old/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"This example demonstrates an end-to-end workflow using QuadraticKalman.jl. In this example we simulate state and observation data, run the Kalman filter and smoother, plot the results, and finally compute the negative log-likelihood along with its gradients.","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"using QuadraticKalman\nusing Random, LinearAlgebra, Statistics, Plots\n\n# Step 1: Set Parameters\nN = 2                       # Number of states\nM = 2                       # Number of measurements\nT = 100                     # Number of time periods to simulate\nseed = 2314                 # Random seed for reproducibility\nRandom.seed!(seed)\n\n# Generate stable state transition parameters\nPhi = [0.5 0.1; 0.1 0.3]    # Autoregressive (state transition) matrix\nmu = [0.1, 0.2]             # State drift vector\nSigma = [0.6 0.15; 0.15 0.4] # State noise covariance matrix\nOmega = cholesky(Sigma).L   # Scale for state noise\n\n# Measurement parameters\nA = [0.0, 0.0]              # Measurement drift vector\nB = [1.0 0.0; 0.0 1.0]      # Measurement matrix linking state to observation\nC = [[0.2 0.1; 0.1 0.0],     # Quadratic effect for first measurement\n     [0.0 0.1; 0.1 0.2]]     # Quadratic effect for second measurement\nV = [0.2 0.0; 0.0 0.2]      # Measurement noise covariance matrix\nD = cholesky(V).L           # Scale for measurement noise\nalpha = zeros(M, M)         # Measurement autoregressive matrix\n\n# Step 2: Simulate States\nX = zeros(N, T)\nX[:, 1] = (I - Phi) \\ mu     # Initialize state at the unconditional mean\nfor t in 1:(T-1)\n    shock = randn(N)\n    X[:, t+1] = mu + Phi * X[:, t] + Omega * shock\nend\n\n# Step 3: Simulate Observations\nY = zeros(M, T)\nfor t in 1:T\n    noise = randn(M)\n    xt = X[:, t]\n\n    # Linear component\n    Y[:, t] = A + B * xt\n\n    # Include autoregressive measurement component if t > 1\n    if t > 1\n        Y[:, t] += alpha * Y[:, t-1]\n    end\n\n    # Add quadratic effects for each measurement\n    for i in 1:M\n        Y[i, t] += xt' * C[i] * xt\n    end\n\n    # Add measurement noise\n    Y[:, t] += D * noise\nend\n\n# Step 4: Define and Initialize the Model\nmodel = QKModel(N, M, mu, Phi, Omega, A, B, C, D, alpha)\n\n# Step 5: Create Data Structure and Run the Filter\ndata = QKData(Y)\nresults = qkf_filter(data, model)\n\n# Step 6: Run the Smoother\nresults_smoother = qkf_smoother(results, model)\n\n# Display Log-Likelihood and Plot Results\nprintln(\"Filter Log-Likelihood: \", sum(results.ll_t))\nplot(kalman_filter_truth_plot(X, results))\nplot(kalman_smoother_truth_plot(X, results_smoother))\nplot(kalman_filter_plot(results))\nplot(kalman_smoother_plot(results_smoother))\n\n# Step 7: Model-Parameter Conversion and Gradient Analysis\nparams = model_to_params(model)\nmodel_from_params = params_to_model(params, N, M)\n\n# Compute negative log-likelihood function for automatic differentiation\nnll(params) = qkf_negloglik(params, data, N, M)\n\nusing ForwardDiff, FiniteDiff\ngrad = ForwardDiff.gradient(nll, params)\ngrad_fd = FiniteDiff.finite_difference_gradient(nll, params)\nprintln(\"Max absolute difference in gradients: \", maximum(abs.(grad - grad_fd)))\nprintln(\"Hessian condition number: \", cond(ForwardDiff.hessian(nll, params)))","category":"page"},{"location":"examples_old/","page":"Examples","title":"Examples","text":"This example illustrates how to simulate data, apply the Quadratic Kalman Filter and Smoother, visualize the results, and verify parameter estimation via gradient computations.","category":"page"}]
}
