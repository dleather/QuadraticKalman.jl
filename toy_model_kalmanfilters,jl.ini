# This code simulates and estimates the Latent-OU State, Linear-Quadratic Measurement model
# found in the PDF "Thoughts on NL-TSM" in Section 2 - Section 3
using RevisePlots, Statistics, StochasticDiffEq, LinearAlgebra, SparseArrays, Random, FLoops,
    KalmanFilters

θ_z_init = 0.5
σ_z_init = 1.0
θ_y_init = 0.5
σ_y_init = σ_z_init * 0.1
ξ₀_init = 0.1
ξ₁_init = 0.1
α_init = 0.0

u0 = [0.0, 0.0]
#params = [θ_z => 1.0, σ_z => 1.0, θ_y => 1.0, σ_y => 1.0, ξ₀ => 1.0, ξ₁ => 1.0, α => 1.0]

#Define the model
function drift!(du,u,p,t)
    du[1] = θ_y_init * (α_init - u[1]) + ξ₀_init * u[2] + ξ₁_init * u[2]^2
    du[2] = -θ_z_init * u[2]
end
   
function diffusion!(du,u,p,t)
    du[1] = σ_y_init
    du[2] = σ_z_init
end

dt = 0.25
tspan = (0.0, 150)
prob = SDEProblem(drift!, diffusion!, u0, tspan)

sol = solve(prob, SOSRA(), saveat = dt)

plot(sol, idxs=(0,1), linewidth=2, label="Y")
plot!(sol, idxs=(0,2), linewidth=2, label="Z")

#Compute correlation
cor([sol.u[i][1] for i in 1:length(sol.u)], [sol.u[i][2] for i in 1:length(sol.u)])

#Try to filter out z using QuadraticKalman.jl

lags = 1
N = 2
M = 1
μ = [0.0 , 0.0]
Φ = [exp(-θ_z_init * dt) 0.0; 1.0 0.0]
Ω = [σ_z_init^2 * (1 - exp(-2 * θ_z_init * dt)) / (2 * θ_z_init) 0.0; 0.0 0.0]
A = [α_init * (1 - exp(-θ_y_init * dt))]
α = reshape([exp(-θ_y_init * dt)], (1,1))
B = reshape([dt * ξ₀_init / 2.0, dt * ξ₀_init / 2.0 * exp(-θ_y_init * dt)], (1,2))
C = [[(dt * ξ₁_init / 2.0) 0.0; 0.0 (dt * ξ₁_init / 2.0 * exp(-θ_y_init * dt))]]
D = reshape([σ_y_init], (1,1))

params =  QKParams(N, M, μ, Φ, Ω, A, B, C, D, α)
N_boot = 10_000
out_mat = zeros(N_boot)

Random.seed!(123124)

# Pre-allocate data array for filtering
data = zeros(1, length(sol.u))

@floop for i = 1:N_boot
    sol = solve(prob, SOSRA(), saveat = dt)
    for j in 1:length(sol.u)
        data[j] = sol.u[j][1]
    end

    qkdata = QKData(data)
    Zₜₜ, Pₜₜ, Yₜₜ₋₁, Mₜₜ₋₁, Kₜ, Zₜₜ₋₁, Pₜₜ₋₁, Σₜₜ₋₁ = qkf_filter(qkdata, params)
    out_mat[i] = cor([sol.u[j][2] for j in 1:length(sol.u)], Zₜₜ[1,:])
end


histogram(out_mat, label="Correlation between Z and Filtered Z", color="blue")
vline!([mean(out_mat)])
data = [sol.u[i][1] for i in 1:length(sol.u)]
data = reshape(data, (1, length(data)))

qkdata = QKData(data)
Zₜₜ, Pₜₜ, Yₜₜ₋₁, Mₜₜ₋₁, Kₜ, Zₜₜ₋₁, Pₜₜ₋₁, Σₜₜ₋₁ = qkf_filter(qkdata, params)

#Plot confidence interval using Mₜₜ₋₁ as shaded area
f1 = plot(Yₜₜ₋₁', ribbon=2*sqrt.(Mₜₜ₋₁[1,1,:]), label="E[Yₜ | Yₜ₋₁] w/ 95% Confidence Interval", color="red",
    fillalpha=0.2, fillcolor=:red, linealpha=1.0, linestyle = :dash)
plot!(data',label = "Yₜ", color = "blue", linewidth = 1)
title!("Measurement Model")
#Put legend in bottom right
plot!(legend=:topright, legendalpha = 0.5)
#Plot the filtered Z
f2 = plot(Zₜₜ[1,:], ribbon=2*sqrt.(Pₜₜ[1,1,:]), label="E[Zₜ | Yₜ] w/ 95% Confidence Interval", color="red",
    fillalpha=0.2, fillcolor=:red, linealpha=1.0, linestyle = :dash)
plot!([sol.u[i][2] for i in 1:length(sol.u)] ,label = "Zₜ", color = "blue", linewidth = 1)
plot!(legend=:topright, legendalpha = 0.5)
title!("Latent State")


#Plot figure 1 and figure 2 atop one another
plot(f1, f2, layout=(2,1), size=(800, 400))

#Plot the correlation between Z and Filtered Z
cor([sol.u[i][2] for i in 1:length(sol.u)], Zₜₜ[1,:])
cor(data', Zₜₜ[1,:])